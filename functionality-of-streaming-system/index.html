<!doctype html>
<html lang="jp">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name="hugo-theme" content="Axiom 0.7.0">



  <link rel="icon" type="image/png" sizes="32x32" href="/image/brand/favicon.png">
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/">
  <link rel="canonical" href="https://soonraah.github.io/functionality-of-streaming-system/">
<link rel="preload" as="style" href="/bundle.css?v=1604733798" media="all">
<link rel="stylesheet" href="/bundle.css?v=1604733798" media="all">
<style>.cdata pre{color:#edf2f7;background-color:#2d3748}.cdata :not(pre)>code{color:#805ad5;background-color:#f7fafc}.chroma .err{color:#fed7d7;background-color:#9b2c2c}.chroma .hl{background-color:#4a5568}.chroma .ln{color:#a0aec0}.chroma .k,.chroma .kc,.chroma .kd,.chroma .kn,.chroma .kp,.chroma .kr{color:#63b3ed}.chroma .kt{color:#b794f4}.chroma .na{color:#f6e05e}.chroma .nb{color:#f6ad55}.chroma .nc{color:#fc8181}.chroma .no{color:#68d391}.chroma .nd{color:#fc8181}.chroma .ne{color:#fc8181}.chroma .nf{color:#f6ad55}.chroma .nt{color:#fc8181}.chroma .l{color:#b794f4}.chroma .dl,.chroma .ld,.chroma .s,.chroma .s2,.chroma .sa,.chroma .sb,.chroma .sc,.chroma .sd{color:#68d391}.chroma .se{color:#a0aec0}.chroma .s1,.chroma .sh,.chroma .si,.chroma .sr,.chroma .ss,.chroma .sx{color:#68d391}.chroma .il,.chroma .m,.chroma .mb,.chroma .mf,.chroma .mh,.chroma .mi,.chroma .mo{color:#b794f4}.chroma .o,.chroma .ow{color:#90cdf4}.chroma .p{color:#cbd5e0}.chroma .c,.chroma .c1,.chroma .ch,.chroma .cm,.chroma .cp,.chroma .cpf,.chroma .cs{color:#a0aec0}.chroma .ge{font-style:italic}.chroma .gs{font-weight:700}</style>



<title>ストリーム処理システムに求められる機能性、および Apache Flink におけるその対応 : Froglog</title>

<meta property="og:title" content="ストリーム処理システムに求められる機能性、および Apache Flink におけるその対応">
<meta property="og:site_name" content="Froglog">
<meta property="og:url" content="https://soonraah.github.io/functionality-of-streaming-system/">
<link rel="image_src" href="https://soonraah.github.io/">
<meta property="og:image" content="https://soonraah.github.io/">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">
<meta property="og:type" content="article">
<meta property="og:locale" content="jp">
<meta property="og:description" content="はじめに このポストではストリーム処理の survay 論文の話題に対して Apache Flink における例を挙げて紹介する。 論文概要 Fragkoulis, M., Carbone, P., Kalavri, V., &amp;amp; Katsifodimos, A. (2020). A Survey on the Evolution of Stream Processing Systems. 2020年の論文。 過去30年ぐらいのストリーム処理のフレームワークを調査し、その発展を論じている。 ストリーム処理に特徴的に求められるいくつかの機能性 (functionality) についてその実現方法をいくつか挙げ、比較的古いフレームワークと最近のフレームワークでの対比を行っている。 このポストのスコープ このポストでは前述のストリーム処理システムに求められる機能性とそれがなぜ必要となるかについて簡単にまとめる。 論文ではそこからさらにその実現方法がいくつか挙げられるが、ここでは個人的に興味がある Apache Flink ではどのように対処しているかを見ていく。 ちなみに論文中では Apache Flink はモダンなフレームワークの1つとしてちょいちょい引き合いに出されている。">
<meta name="description" content="はじめに このポストではストリーム処理の survay 論文の話題に対して Apache Flink における例を挙げて紹介する。 論文概要 Fragkoulis, M., Carbone, P., Kalavri, V., &amp;amp; Katsifodimos, A. (2020). A Survey on the Evolution of Stream Processing Systems. 2020年の論文。 過去30年ぐらいのストリーム処理のフレームワークを調査し、その発展を論じている。 ストリーム処理に特徴的に求められるいくつかの機能性 (functionality) についてその実現方法をいくつか挙げ、比較的古いフレームワークと最近のフレームワークでの対比を行っている。 このポストのスコープ このポストでは前述のストリーム処理システムに求められる機能性とそれがなぜ必要となるかについて簡単にまとめる。 論文ではそこからさらにその実現方法がいくつか挙げられるが、ここでは個人的に興味がある Apache Flink ではどのように対処しているかを見ていく。 ちなみに論文中では Apache Flink はモダンなフレームワークの1つとしてちょいちょい引き合いに出されている。">
<meta property="og:updated_time" content="2020-11-07T07:00:00Z">
<meta property="fb:app_id" content="">
<meta name="author" content="soonraah">
<meta property="article:author" content="https://soonraah.github.io/">
<meta property="article:published_time" content="2020-11-07T07:00:00Z">
<meta property="article:modified_time" content="2020-11-07T07:00:00Z">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": "ストリーム処理システムに求められる機能性、および Apache Flink におけるその対応",
  "alternativeHeadline": "はじめに このポストではストリーム処理の survay 論文の話題に対して Apache Flink における例を挙げて紹介する。 論文概要 Fragkoulis, M., Carbone, P., Kalavri, V., \u0026amp; Katsifodimos, A. (2020). A Survey on the Evolution of Stream Processing Systems. 2020年の論文。 過去30年ぐらいのストリーム処理のフレームワークを調査し、その発展を論じている。 ストリーム処理に特徴的に求められるいくつかの機能性 (functionality) についてその実現方法をいくつか挙げ、比較的古いフレームワークと最近のフレームワークでの対比を行っている。 このポストのスコープ このポストでは前述のストリーム処理システムに求められる機能性とそれがなぜ必要となるかについて簡単にまとめる。 論文ではそこからさらにその実現方法がいくつか挙げられるが、ここでは個人的に興味がある Apache Flink ではどのように対処しているかを見ていく。 ちなみに論文中では Apache Flink はモダンなフレームワークの1つとしてちょいちょい引き合いに出されている。",
  "url": "https://soonraah.github.io/functionality-of-streaming-system/",
  "image": "https://soonraah.github.io/",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://soonraah.github.io/functionality-of-streaming-system/"
  },
  "description": "はじめに このポストではストリーム処理の survay 論文の話題に対して Apache Flink における例を挙げて紹介する。 論文概要 Fragkoulis, M., Carbone, P., Kalavri, V., \u0026amp; Katsifodimos, A. (2020). A Survey on the Evolution of Stream Processing Systems. 2020年の論文。 過去30年ぐらいのストリーム処理のフレームワークを調査し、その発展を論じている。 ストリーム処理に特徴的に求められるいくつかの機能性 (functionality) についてその実現方法をいくつか挙げ、比較的古いフレームワークと最近のフレームワークでの対比を行っている。 このポストのスコープ このポストでは前述のストリーム処理システムに求められる機能性とそれがなぜ必要となるかについて簡単にまとめる。 論文ではそこからさらにその実現方法がいくつか挙げられるが、ここでは個人的に興味がある Apache Flink ではどのように対処しているかを見ていく。 ちなみに論文中では Apache Flink はモダンなフレームワークの1つとしてちょいちょい引き合いに出されている。",
  "author": {
    "@type": "Person",
    "name": "soonraah"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Froglog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://soonraah.github.io/"
    }
  },
  "datePublished": "2020-11-07T07:00:00Z",
  "dateModified": "2020-11-07T07:00:00Z",
  "articleBody": "\u003ch2 id=\"はじめに\"\u003eはじめに\u003c/h2\u003e\n\u003cp\u003eこのポストではストリーム処理の survay 論文の話題に対して Apache Flink における例を挙げて紹介する。\u003c/p\u003e\n\u003ch3 id=\"論文概要\"\u003e論文概要\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://arxiv.org/abs/2008.00842\"\u003eFragkoulis, M., Carbone, P., Kalavri, V., \u0026amp; Katsifodimos, A. (2020). A Survey on the Evolution of Stream Processing Systems.\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e2020年の論文。\u003cbr\u003e\n過去30年ぐらいのストリーム処理のフレームワークを調査し、その発展を論じている。\u003cbr\u003e\nストリーム処理に特徴的に求められるいくつかの機能性 (functionality) についてその実現方法をいくつか挙げ、比較的古いフレームワークと最近のフレームワークでの対比を行っている。\u003c/p\u003e\n\u003ch3 id=\"このポストのスコープ\"\u003eこのポストのスコープ\u003c/h3\u003e\n\u003cp\u003eこのポストでは前述のストリーム処理システムに求められる機能性とそれがなぜ必要となるかについて簡単にまとめる。\u003cbr\u003e\n論文ではそこからさらにその実現方法がいくつか挙げられるが、ここでは個人的に興味がある Apache Flink ではどのように対処しているかを見ていく。\u003cbr\u003e\nちなみに論文中では Apache Flink はモダンなフレームワークの1つとしてちょいちょい引き合いに出されている。\u003cbr\u003e\nここでは Flink v1.11 をターゲットとする。\u003c/p\u003e\n\u003cp\u003e以下では論文で挙げられている機能性に沿って記載していく。\u003c/p\u003e\n\u003ch2 id=\"out-of-order-data-management\"\u003eOut-of-order Data Management\u003c/h2\u003e\n\u003ch3 id=\"out-of-order\"\u003eOut-of-order\u003c/h3\u003e\n\u003cp\u003eストリーム処理システムにやってくるデータの順序は外的・内的要因により期待される順序になっていないことがある。\u003cbr\u003e\n外的要因としてよくあるのはネットワークの問題。\u003cbr\u003e\nデータソース (producer) からストリーム処理システムに届くまでのルーティング、負荷など諸々の条件により各レコードごとに転送時間は一定にはならない。\u003cbr\u003e\n各 operator の処理などストリーム処理システムの内的な要因で順序が乱されることもある。\u003cbr\u003e\nout-of-order は処理の遅延や正しくない結果の原因となることがある。\u003c/p\u003e\n\u003cp\u003eout-of-order を管理するためにストリーム処理システムは処理の進捗を検出する必要がある。\u003cbr\u003e\n\u0026quot;進捗\u0026quot; とはある時間経過でレコードの処理がどれだけ進んだかというもので、レコードの順序を表す属性 \u003cem\u003eA\u003c/em\u003e (ex. event time) により定量化される。\u003cbr\u003e\nある期間で処理された最古の \u003cem\u003eA\u003c/em\u003e を進捗の尺度とみなすことができる。\u003c/p\u003e\n\u003ch3 id=\"apache-flink-の場合\"\u003eApache Flink の場合\u003c/h3\u003e\n\u003cp\u003eFlink ではこの進捗を測るのに \u003cstrong\u003ewatermark\u003c/strong\u003e という概念が使われている。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/timely-stream-processing.html#event-time-and-watermarks\"\u003eEvent Time and Watermarks\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\u003cfigure class=\"center\"\u003e\n\u003cimg\nclass=\"mb-2 mx-auto leading-none shadow-xl\"\nsrc=\"/image/flink/stream_watermark_out_of_order.svg\"\nalt=\"Apache Flink\"\u003e\n\u003cfigcaption class=\"text-sm text-right text-raven-500\"\u003e\n\u003cp\u003eApache Flink \u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/timely-stream-processing.html#event-time-and-watermarks\"\u003eEvent Time and Watermarks\u003c/a\u003e\u003c/p\u003e\n\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\u003cp\u003eこちらの図でストリーム中の破線で描かれているのが watermark であり、\u003cem\u003eW(11)\u003c/em\u003e の wartermark は「timestamp が11以下の event はこの後もう来ないものとみなす」ということを下流の operator に伝えるものである。\u003cbr\u003e\nwatermark は metadata 的なものだが、通常の event と同じようにストリーム中を流れている (これを panctuation という)。\u003cbr\u003e\n下流の operator が window 処理をしていた場合、\u003cem\u003eW(11)\u003c/em\u003e が届いた時点で timestamp が11までのところの window 処理を完結してさらに下流に output することができる。\u003c/p\u003e\n\u003cp\u003ewatermark がいつ・どのような値で発生するかについては Flink application の開発者の実装次第ということになる。\u003cbr\u003e\nしかし現実的には \u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/event_timestamps_watermarks.html#writing-a-periodic-watermarkgenerator\"\u003eWriting a Periodic WatermarkGenerator\u003c/a\u003e の例にある \u003ccode\u003eBoundedOutOfOrdernessGenerator\u003c/code\u003e のように、 \u003ccode\u003eWatermarkGenerator\u003c/code\u003e にやってきた event の event time を元に決めることが多いと思われる。\u003c/p\u003e\n\u003ch2 id=\"state-management\"\u003eState Management\u003c/h2\u003e\n\u003ch3 id=\"ストリーム処理における状態\"\u003eストリーム処理における状態\u003c/h3\u003e\n\u003cp\u003e\u0026quot;状態\u0026quot; とは継続的なストリーム処理の中で内部的な副作用をとらえたもの。\u003cbr\u003e\nアクティブな window、レコードのかたまり、aggregation の進捗など。\u003cbr\u003e\nユーザ定義のものも含まれる。\u003cbr\u003e\n状態については以下のようなトピックがある。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eProgrammability\n\u003cul\u003e\n\u003cli\u003eプログラミングモデルにおいて状態がどのように定義・管理されるか\u003c/li\u003e\n\u003cli\u003e定義と管理についてそれぞれシステムとユーザの場合がある\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eScalability and Persistency\n\u003cul\u003e\n\u003cli\u003e最近のストリーム処理は scalable の時流を汲んでおり、scale out するときに状態をどのように扱うか\u003c/li\u003e\n\u003cli\u003e内外の記憶装置に状態を永続化するという方法がよく取られる\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eConsistency\n\u003cul\u003e\n\u003cli\u003etransaction level の保証について\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"apache-flink-の場合-1\"\u003eApache Flink の場合\u003c/h3\u003e\n\u003cp\u003eドキュメントの \u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/\"\u003eTOP ページ\u003c/a\u003e における Flink を表す一文\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eApache Flink is a framework and distributed processing engine for stateful computations over unbounded and bounded data streams.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eにおいても \u0026quot;stateful\u0026quot; という言葉が使われているとおり、状態の扱いは Flink の設計思想の中でもかなり重要な部分となっている。\u003cbr\u003e\nFlink における状態の扱いについてはこちらを参照。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/stateful-stream-processing.html\"\u003eStateful Stream Processing\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"programmability\"\u003eProgrammability\u003c/h4\u003e\n\u003cp\u003eFlink では application 開発者が任意の状態を定義することができる。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/state.html\"\u003eWorking with State\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e一方で状態の管理はフレームワーク側でやってくれるので、開発者は checkpoint や restore 等のことは特に配慮する必要はない。\u003cbr\u003e\n論文中ではこれを \u0026quot;User-Declared System-Managed State\u0026quot; と呼んでおり、最近のストリーム処理システムの傾向となっている。\u003c/p\u003e\n\u003ch4 id=\"scalability\"\u003eScalability\u003c/h4\u003e\n\u003cp\u003eFlink では \u003ccode\u003ekeyBy()\u003c/code\u003e により key-level の状態を持つことができる。\u003cbr\u003e\nkey ごとに並列 task 内での partitioning し、分散することが可能ということである。\u003c/p\u003e\n\u003ch4 id=\"persistency\"\u003ePersistency\u003c/h4\u003e\n\u003cp\u003e論文では永続化については scalability と絡めて述べられていたが、\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/stateful-stream-processing.html#state-persistence\"\u003eFlink のドキュメント\u003c/a\u003eでは fault tolerance の文脈で永続化について書かれている。\u003c/p\u003e\n\u003cp\u003eFlink の fault tolerance の肝は stream replay と checkpointing である。\u003cbr\u003e\ncheckpointing とはストリームと operator の状態の一貫性のあるスナップショットをとることである。\u003c/p\u003e\n\n\n\u003cfigure class=\"center\"\u003e\n\u003cimg\nclass=\"mb-2 mx-auto leading-none shadow-xl\"\nsrc=\"/image/flink/checkpointing.svg\"\nalt=\"Apache Flink\"\u003e\n\u003cfigcaption class=\"text-sm text-right text-raven-500\"\u003e\n\u003cp\u003eApache Flink \u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/stateful-stream-processing.html#snapshotting-operator-state\"\u003eSnapshotting Operator State\u003c/a\u003e\u003c/p\u003e\n\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\u003cp\u003eこの checkpoint を作成する過程で各 operator の状態が state backend へと永続化される。\u003cbr\u003e\nstate backend では \u003ca href=\"https://rocksdb.org/\"\u003eRocksDB\u003c/a\u003e の key/value store に各 checkpoint, 各 operator の状態が保存される。\u003cbr\u003e\n(RocksDB 以外にもメモリやファイルシステムなどもある)\u003c/p\u003e\n\u003ch4 id=\"consistency\"\u003eConsistency\u003c/h4\u003e\n\u003cp\u003eFlink では checkpoint のインターバルの期間の単位 (epoch という) で一貫性のある状態を永続化する。\u003cbr\u003e\n上図の barriers がその単位を決めている。\u003cbr\u003e\nChandy Lamport algorithm という分散スナップショットの手法がインスパイアされており、unaligned/aligned で各 operator の状態のスナップショットを取るようになっている。\u003c/p\u003e\n\u003ch2 id=\"fault-tolerance--high-availability\"\u003eFault Tolerance \u0026amp; High Availability\u003c/h2\u003e\n\u003ch3 id=\"fault-tolerance\"\u003eFault Tolerance\u003c/h3\u003e\n\u003cp\u003eストリーム処理システムにとって fault tolerance は2つの理由から重要である。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eストリーム処理システムは stateful な計算を終わりのないデータに対して行っている\n\u003cul\u003e\n\u003cli\u003efault tolerance がなければ、障害があったときに最初から状態を計算しなおさなければならない\u003c/li\u003e\n\u003cli\u003e一方で、多くの場合過去に処理されたデータは既に失われている\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e最近のストリーム処理システムは分散アーキテクチャを採用している\n\u003cul\u003e\n\u003cli\u003e物理マシンの数だけ問題が起こりやすくなる\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eoutput commit problem についても考慮する必要がある。\u003cbr\u003e\nこれは出力が公開された位置から状態を復元できることが確かな場合のみ、システムは外界に出力を公開するというもの。\u003cbr\u003e\n言い換えると、障害からの復旧時などに同じ出力を2回してしまわない、出力を \u003cem\u003eexactly-once\u003c/em\u003e にできるかというものである。\u003c/p\u003e\n\u003ch3 id=\"high-availability\"\u003eHigh Availability\u003c/h3\u003e\n\u003cp\u003e過去の研究においてストリーム処理システムの可用性は recovery time, performance overhead (throughput \u0026amp; latency), resource utilization により定量化されてきた。\u003cbr\u003e\nこの論文では\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eA streaming system is available when it can provide output based on the processing of its current input.\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eを可用性の定義として提案する。\u003cbr\u003e\n時間ごとの processing time と event time の差により定量化される。\u003c/p\u003e\n\u003ch3 id=\"apache-flink-の場合-2\"\u003eApache Flink の場合\u003c/h3\u003e\n\u003ch4 id=\"fault-tolerance-1\"\u003eFault Tolerance\u003c/h4\u003e\n\u003cp\u003e論文中では Flink は output commit problem については Kafka などの出力先の外部システムの責任とするスタンスだとしている。\u003cbr\u003e\nKafka には \u003ca href=\"https://cwiki.apache.org/confluence/display/KAFKA/Idempotent+Producer\"\u003eidempotent producer\u003c/a\u003e という機能があり、たぶんこれのことを言っている。\u003c/p\u003e\n\u003cp\u003eまた一方で \u003ccode\u003eTwoPhaseCommitSinkFunction\u003c/code\u003e の2相コミットによって \u003cem\u003eexectly-once\u003c/em\u003e semantics を提供するという方法も示されている。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://flink.apache.org/features/2018/03/01/end-to-end-exactly-once-apache-flink.html\"\u003eAn Overview of End-to-End Exactly-Once Processing in Apache Flink (with Apache Kafka, too!)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003echeckpointing における JobManager を2相コミットの coordinator とみなし、checkpoint barrier が最後の operator に到達するまでをコミット要求相、その後の JobManager からの checkpointing 完了通知をコミット相としている。\u003cbr\u003e\nコミット相において外部システムへの書き出しの transaction が完了する形となる。\u003c/p\u003e\n\u003cp\u003efault tolerance については State Management の項も参照。\u003c/p\u003e\n\u003ch4 id=\"high-availability-1\"\u003eHigh Availability\u003c/h4\u003e\n\u003cp\u003eFlink のプロセスには \u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/flink-architecture.html#anatomy-of-a-flink-cluster\"\u003eJobManager と TaskManager\u003c/a\u003e があり、前者は cluster に1つだけ動く。\u003cbr\u003e\nしたがって JobManager が SPOF になり、可用性に影響しうる。\u003c/p\u003e\n\u003cp\u003ehigh availability (高可用性) を実現するためには JobManager が SPOF となることを避けることができる。\u003cbr\u003e\nstandalone または YARN の cluster として deploy した場合は JobManager が SPOF となることを避けることができる。\u003c/p\u003e\n\u003cp\u003e以下は standalone の例。\u003cbr\u003e\n1つの JobManager が leader として動いているが、それが crash すると standby のインスタンスが leader を引き継ぐ。\u003cbr\u003e\n(論文中では passive replication として紹介)\u003c/p\u003e\n\n\n\u003cfigure class=\"center\"\u003e\n\u003cimg\nclass=\"mb-2 mx-auto leading-none shadow-xl\"\nsrc=\"/image/flink/jobmanager_ha_overview.png\"\nalt=\"Apache Flink\"\u003e\n\u003cfigcaption class=\"text-sm text-right text-raven-500\"\u003e\n\u003cp\u003eApache Flink \u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/jobmanager_high_availability.html#standalone-cluster-high-availability\"\u003eStandalone Cluster High Availability\u003c/a\u003e\u003c/p\u003e\n\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\u003ch2 id=\"load-management-elasticity--reconfiguration\"\u003eLoad Management, Elasticity \u0026amp; Reconfiguration\u003c/h2\u003e\n\u003ch3 id=\"load-management\"\u003eLoad Management\u003c/h3\u003e\n\u003cp\u003eストリーム処理システムは、外部のデータソースがデータを送る流速を制御することができない。\u003cbr\u003e\n入力データの流速がシステムのキャパより大きいことによるパフォーマンス劣化を防ぐための対応が必要となる。\u003cbr\u003e\n次のような手法がある。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eload shedding\n\u003cul\u003e\n\u003cli\u003e多すぎる入力データを落とす方法\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eback-pressure\n\u003cul\u003e\n\u003cli\u003e入力データを落とせないときに buffering と組み合わせて使う\u003c/li\u003e\n\u003cli\u003edataflow graph 上に速度制限が波及していく\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eelasticity\n\u003cul\u003e\n\u003cli\u003e分散アーキテクチャと cloud にもとづく方法\u003c/li\u003e\n\u003cli\u003eいわゆる scale out\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"apache-flink-の場合-3\"\u003eApache Flink の場合\u003c/h3\u003e\n\u003cp\u003eFlink では \u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/monitoring/back_pressure.html#back-pressure\"\u003eback pressure\u003c/a\u003e および elasticity の組み合わせとなっている。\u003c/p\u003e\n\u003cp\u003eback pressure は一時的な入力データの増加に対応する。\u003cbr\u003e\n各 operator (subtask?) は入出力の buffer を持っており、これにより operator 間の処理速度の違いをある程度吸収できる。\u003cbr\u003e\nしかし入力データが著しく多くなると\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eボトルネックとなる operator の処理が滞る\u003c/li\u003e\n\u003cli\u003eその operator の入力 buffer がいっぱいになる\u003c/li\u003e\n\u003cli\u003e(ボトルネックではない) 上流の operator の出力 buffer がいっぱいになる\u003c/li\u003e\n\u003cli\u003e上流の operator の処理が滞る\u003c/li\u003e\n\u003cli\u003e(以降繰り返し)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eのように、dataflow graph の上流へ上流へと遅延が波及する。\u003c/p\u003e\n\u003cp\u003eelasticity の面では、JobManager や TaskManager の追加や削除ができるようになっている。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/deployment/cluster_setup.html#adding-jobmanagertaskmanager-instances-to-a-cluster\"\u003eAdding JobManager/TaskManager Instances to a Cluster\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTaskManager の追加や削除においては状態の再配分が行われる。\u003cbr\u003e\n再配分される状態は key group という単位で partitioning されており、consistent hash 的な方法で各 TaskManager 配下の operator へと配分される。\u003c/p\u003e\n\u003cp\u003eちなみに AWS が提供する Flink の managed service である Amazon Kinesis Data Analytics for Apache Flink では CPU 使用率をモニタリングして自動的に scale out が行われるようになっている。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.aws.amazon.com/kinesisanalytics/latest/java/how-scaling.html\"\u003eApplication Scaling in Kinesis Data Analytics for Apache Flink\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"まとめ\"\u003eまとめ\u003c/h2\u003e\n\u003cp\u003eバッチ処理ではあまりクリティカルにならないような問題でもストリーム処理では重大な影響を及ぼすことがある。\u003cbr\u003e\nストリーム処理に求められる機能性を実現するに当たり、Apache Flink では checkpoint の仕組みが中心的な役割を果たしているということが理解できた。\u003c/p\u003e"
}
</script>

<link rel="preload" as="script" href="/bundle.js?v=1604733798">

<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://stats.g.doubleclick.net">
<link rel="preconnect" href="https://www.googleadservices.com">
<link rel="preload" as="script" href="https://www.googletagmanager.com/gtag/js?id=UA-73329599-2">
<script src="https://www.googletagmanager.com/gtag/js?id=UA-73329599-2"></script>
<script>
  window.dataLayer=window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js',new Date());
  gtag('config','UA-73329599-2');
</script>

</head>
<body>

  <header id="nav" class="header">
  <div class="ax-l-i max-w-6xl">
    <div class="ax-logo">
      <a class="block" href="/" title="Froglog"><span class="font-semibold text-raven-900">Froglog</span></a>
    </div>
    <div class="ax-user">
      <a class="p-2 w-8 h-8 block text-raven-500 hover:text-gray-800 focus:text-gray-800 focus:outline-none" target="_blank" rel="noopener nofollow" href="https://www.google.com/search?q=site:soonraah.github.io" title="Search">
        <svg class="fill-current" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M2.67 12.804c0-5.6 4.544-10.134 10.133-10.134s10.134 4.544 10.134 10.134-4.544 10.133-10.134 10.133S2.67 18.393 2.67 12.804zm28.943 16.923l-8.868-8.868c4.287-5.3 3.68-13.012-1.378-17.57S8.564-1.066 3.75 3.75s-5.017 12.558-.46 17.618 12.28 5.665 17.57 1.378l8.868 8.868a1.33 1.33 0 0 0 2.231-.597c.123-.46-.008-.952-.345-1.29h0z"/></svg>

      </a>
      <a class="p-2 block text-base leading-none text-raven-500 hover:text-gray-800 focus:text-gray-800 focus:outline-none" href="/posts/">
        Posts
      </a>
      <a class="p-2 block text-base leading-none text-raven-500 hover:text-gray-800 focus:text-gray-800 focus:outline-none" href="/tags/">
        Tags
      </a>
      <a class="p-2 block text-base leading-none text-raven-500 hover:text-gray-800 focus:text-gray-800 focus:outline-none" href="/about/">
        About
      </a>
    </div>
  </div>

  
</header>

  <main>
<div class="default-single">
  <div class="ax-title ax-l-o">
    <div class="ax-l-i max-w-680">
      <h1 class="post-title font-content-title font-normal leading-tight tracking-default text-40">ストリーム処理システムに求められる機能性、および Apache Flink におけるその対応</h1>

      <div class="ax-meta flex items-center mt-5">
        <div class="flex-grow min-w-0">
          <div class="flex items-center">
  <div class="flex-shrink-0">
    <img
    class="w-12 h-12 sm:w-14 sm:h-14 object-cover p-3px rounded-full border border-blue-300"
    src="/image/author/soonraah.png"
    alt="soonraah">
  </div>
  <div class="flex-shrink-0 ml-2 leading-tight font-content-sans">
    <a class="block text-sm text-raven-800 hover:text-raven-900 hover:underline focus:underline" target="_blank" rel="noopener nofollow" title="soonraah" href="https://soonraah.github.io/">soonraah</a>
    <time class="text-sm text-raven-500" datetime="2020-11-07T07:00:00Z">2020-11-07 16:00</time>
  </div>
</div>

        </div>
        <div>
          <div class="flex items-center">
  <a class="flex-shrink-0 block text-raven-800 hover:text-raven-900" target="_blank" rel="noopener nofollow" title="Share on Twitter" href="https://twitter.com/intent/tweet?text=%e3%82%b9%e3%83%88%e3%83%aa%e3%83%bc%e3%83%a0%e5%87%a6%e7%90%86%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0%e3%81%ab%e6%b1%82%e3%82%81%e3%82%89%e3%82%8c%e3%82%8b%e6%a9%9f%e8%83%bd%e6%80%a7%e3%80%81%e3%81%8a%e3%82%88%e3%81%b3%20Apache%20Flink%20%e3%81%ab%e3%81%8a%e3%81%91%e3%82%8b%e3%81%9d%e3%81%ae%e5%af%be%e5%bf%9c%20by%20%40soonraah%20https%3a%2f%2fsoonraah.github.io%2ffunctionality-of-streaming-system%2f"><svg class="w-6 h-6 fill-current" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M32 6.078c-1.2.522-2.458.868-3.78 1.036 1.36-.812 2.398-2.088 2.886-3.626a13.11 13.11 0 0 1-4.16 1.588C25.742 3.794 24.026 3 22.154 3a6.56 6.56 0 0 0-6.556 6.562c0 .52.044 1.02.152 1.496-5.454-.266-10.28-2.88-13.522-6.862-.566.982-.898 2.106-.898 3.316a6.57 6.57 0 0 0 2.914 5.452 6.48 6.48 0 0 1-2.964-.808v.072c0 3.188 2.274 5.836 5.256 6.446-.534.146-1.116.216-1.72.216-.42 0-.844-.024-1.242-.112.85 2.598 3.262 4.508 6.13 4.57a13.18 13.18 0 0 1-8.134 2.798c-.538 0-1.054-.024-1.57-.1C2.906 27.93 6.35 29 10.064 29c12.072 0 18.672-10 18.672-18.668 0-.3-.01-.57-.024-.848C30.014 8.56 31.108 7.406 32 6.078z"/></svg>
</a>
  <a class="ml-3 flex-shrink-0 block text-raven-800 hover:text-raven-900" target="_blank" rel="noopener nofollow" title="Share on Facebook" href="https://www.facebook.com/dialog/share?app_id=&display=page&href=https%3a%2f%2fsoonraah.github.io%2ffunctionality-of-streaming-system%2f"><svg class="w-6 h-6 fill-current" viewBox="-7 -3.5 39 39" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M30.234 0H1.765C.8.001 0 .79 0 1.766v28.47C.001 31.2.79 32 1.766 32h15.328V19.625h-4.156V14.78h4.156v-3.564c0-4.134 2.523-6.384 6.21-6.384 1.766 0 3.284.13 3.726.2v4.32h-2.543c-2.006 0-2.394.953-2.394 2.352v3.085h4.797l-.625 4.844h-4.172V32h8.14C31.21 32 32 31.2 32 30.234V1.765C32 .8 31.21 0 30.234 0z"/></svg>
</a>
</div>

        </div>
      </div>
    </div>
  </div><div class="ax-content ax-l-o">
    <div class="ax-l-i max-w-680">
      <article class="cdata">
<aside class="toc">
  <nav id="TableOfContents">
  <ul>
    <li><a href="#はじめに">はじめに</a>
      <ul>
        <li><a href="#論文概要">論文概要</a></li>
        <li><a href="#このポストのスコープ">このポストのスコープ</a></li>
      </ul>
    </li>
    <li><a href="#out-of-order-data-management">Out-of-order Data Management</a>
      <ul>
        <li><a href="#out-of-order">Out-of-order</a></li>
        <li><a href="#apache-flink-の場合">Apache Flink の場合</a></li>
      </ul>
    </li>
    <li><a href="#state-management">State Management</a>
      <ul>
        <li><a href="#ストリーム処理における状態">ストリーム処理における状態</a></li>
        <li><a href="#apache-flink-の場合-1">Apache Flink の場合</a></li>
      </ul>
    </li>
    <li><a href="#fault-tolerance--high-availability">Fault Tolerance &amp; High Availability</a>
      <ul>
        <li><a href="#fault-tolerance">Fault Tolerance</a></li>
        <li><a href="#high-availability">High Availability</a></li>
        <li><a href="#apache-flink-の場合-2">Apache Flink の場合</a></li>
      </ul>
    </li>
    <li><a href="#load-management-elasticity--reconfiguration">Load Management, Elasticity &amp; Reconfiguration</a>
      <ul>
        <li><a href="#load-management">Load Management</a></li>
        <li><a href="#apache-flink-の場合-3">Apache Flink の場合</a></li>
      </ul>
    </li>
    <li><a href="#まとめ">まとめ</a></li>
  </ul>
</nav>
</aside>
<h2 id="はじめに">はじめに</h2>
<p>このポストではストリーム処理の survay 論文の話題に対して Apache Flink における例を挙げて紹介する。</p>
<h3 id="論文概要">論文概要</h3>
<p><a href="https://arxiv.org/abs/2008.00842">Fragkoulis, M., Carbone, P., Kalavri, V., &amp; Katsifodimos, A. (2020). A Survey on the Evolution of Stream Processing Systems.</a></p>
<p>2020年の論文。<br>
過去30年ぐらいのストリーム処理のフレームワークを調査し、その発展を論じている。<br>
ストリーム処理に特徴的に求められるいくつかの機能性 (functionality) についてその実現方法をいくつか挙げ、比較的古いフレームワークと最近のフレームワークでの対比を行っている。</p>
<h3 id="このポストのスコープ">このポストのスコープ</h3>
<p>このポストでは前述のストリーム処理システムに求められる機能性とそれがなぜ必要となるかについて簡単にまとめる。<br>
論文ではそこからさらにその実現方法がいくつか挙げられるが、ここでは個人的に興味がある Apache Flink ではどのように対処しているかを見ていく。<br>
ちなみに論文中では Apache Flink はモダンなフレームワークの1つとしてちょいちょい引き合いに出されている。<br>
ここでは Flink v1.11 をターゲットとする。</p>
<p>以下では論文で挙げられている機能性に沿って記載していく。</p>
<h2 id="out-of-order-data-management">Out-of-order Data Management</h2>
<h3 id="out-of-order">Out-of-order</h3>
<p>ストリーム処理システムにやってくるデータの順序は外的・内的要因により期待される順序になっていないことがある。<br>
外的要因としてよくあるのはネットワークの問題。<br>
データソース (producer) からストリーム処理システムに届くまでのルーティング、負荷など諸々の条件により各レコードごとに転送時間は一定にはならない。<br>
各 operator の処理などストリーム処理システムの内的な要因で順序が乱されることもある。<br>
out-of-order は処理の遅延や正しくない結果の原因となることがある。</p>
<p>out-of-order を管理するためにストリーム処理システムは処理の進捗を検出する必要がある。<br>
&quot;進捗&quot; とはある時間経過でレコードの処理がどれだけ進んだかというもので、レコードの順序を表す属性 <em>A</em> (ex. event time) により定量化される。<br>
ある期間で処理された最古の <em>A</em> を進捗の尺度とみなすことができる。</p>
<h3 id="apache-flink-の場合">Apache Flink の場合</h3>
<p>Flink ではこの進捗を測るのに <strong>watermark</strong> という概念が使われている。</p>
<ul>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/timely-stream-processing.html#event-time-and-watermarks">Event Time and Watermarks</a></li>
</ul>


<figure class="center">
<img
class="mb-2 mx-auto leading-none shadow-xl"
src="/image/flink/stream_watermark_out_of_order.svg"
alt="Apache Flink">
<figcaption class="text-sm text-right text-raven-500">
<p>Apache Flink <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/timely-stream-processing.html#event-time-and-watermarks">Event Time and Watermarks</a></p>
</figcaption>
</figure>

<p>こちらの図でストリーム中の破線で描かれているのが watermark であり、<em>W(11)</em> の wartermark は「timestamp が11以下の event はこの後もう来ないものとみなす」ということを下流の operator に伝えるものである。<br>
watermark は metadata 的なものだが、通常の event と同じようにストリーム中を流れている (これを panctuation という)。<br>
下流の operator が window 処理をしていた場合、<em>W(11)</em> が届いた時点で timestamp が11までのところの window 処理を完結してさらに下流に output することができる。</p>
<p>watermark がいつ・どのような値で発生するかについては Flink application の開発者の実装次第ということになる。<br>
しかし現実的には <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/event_timestamps_watermarks.html#writing-a-periodic-watermarkgenerator">Writing a Periodic WatermarkGenerator</a> の例にある <code>BoundedOutOfOrdernessGenerator</code> のように、 <code>WatermarkGenerator</code> にやってきた event の event time を元に決めることが多いと思われる。</p>
<h2 id="state-management">State Management</h2>
<h3 id="ストリーム処理における状態">ストリーム処理における状態</h3>
<p>&quot;状態&quot; とは継続的なストリーム処理の中で内部的な副作用をとらえたもの。<br>
アクティブな window、レコードのかたまり、aggregation の進捗など。<br>
ユーザ定義のものも含まれる。<br>
状態については以下のようなトピックがある。</p>
<ul>
<li>Programmability
<ul>
<li>プログラミングモデルにおいて状態がどのように定義・管理されるか</li>
<li>定義と管理についてそれぞれシステムとユーザの場合がある</li>
</ul>
</li>
<li>Scalability and Persistency
<ul>
<li>最近のストリーム処理は scalable の時流を汲んでおり、scale out するときに状態をどのように扱うか</li>
<li>内外の記憶装置に状態を永続化するという方法がよく取られる</li>
</ul>
</li>
<li>Consistency
<ul>
<li>transaction level の保証について</li>
</ul>
</li>
</ul>
<h3 id="apache-flink-の場合-1">Apache Flink の場合</h3>
<p>ドキュメントの <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/">TOP ページ</a> における Flink を表す一文</p>
<blockquote>
<p>Apache Flink is a framework and distributed processing engine for stateful computations over unbounded and bounded data streams.</p>
</blockquote>
<p>においても &quot;stateful&quot; という言葉が使われているとおり、状態の扱いは Flink の設計思想の中でもかなり重要な部分となっている。<br>
Flink における状態の扱いについてはこちらを参照。</p>
<ul>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/stateful-stream-processing.html">Stateful Stream Processing</a></li>
</ul>
<h4 id="programmability">Programmability</h4>
<p>Flink では application 開発者が任意の状態を定義することができる。</p>
<ul>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/state.html">Working with State</a></li>
</ul>
<p>一方で状態の管理はフレームワーク側でやってくれるので、開発者は checkpoint や restore 等のことは特に配慮する必要はない。<br>
論文中ではこれを &quot;User-Declared System-Managed State&quot; と呼んでおり、最近のストリーム処理システムの傾向となっている。</p>
<h4 id="scalability">Scalability</h4>
<p>Flink では <code>keyBy()</code> により key-level の状態を持つことができる。<br>
key ごとに並列 task 内での partitioning し、分散することが可能ということである。</p>
<h4 id="persistency">Persistency</h4>
<p>論文では永続化については scalability と絡めて述べられていたが、<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/stateful-stream-processing.html#state-persistence">Flink のドキュメント</a>では fault tolerance の文脈で永続化について書かれている。</p>
<p>Flink の fault tolerance の肝は stream replay と checkpointing である。<br>
checkpointing とはストリームと operator の状態の一貫性のあるスナップショットをとることである。</p>


<figure class="center">
<img
class="mb-2 mx-auto leading-none shadow-xl"
src="/image/flink/checkpointing.svg"
alt="Apache Flink">
<figcaption class="text-sm text-right text-raven-500">
<p>Apache Flink <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/stateful-stream-processing.html#snapshotting-operator-state">Snapshotting Operator State</a></p>
</figcaption>
</figure>

<p>この checkpoint を作成する過程で各 operator の状態が state backend へと永続化される。<br>
state backend では <a href="https://rocksdb.org/">RocksDB</a> の key/value store に各 checkpoint, 各 operator の状態が保存される。<br>
(RocksDB 以外にもメモリやファイルシステムなどもある)</p>
<h4 id="consistency">Consistency</h4>
<p>Flink では checkpoint のインターバルの期間の単位 (epoch という) で一貫性のある状態を永続化する。<br>
上図の barriers がその単位を決めている。<br>
Chandy Lamport algorithm という分散スナップショットの手法がインスパイアされており、unaligned/aligned で各 operator の状態のスナップショットを取るようになっている。</p>
<h2 id="fault-tolerance--high-availability">Fault Tolerance &amp; High Availability</h2>
<h3 id="fault-tolerance">Fault Tolerance</h3>
<p>ストリーム処理システムにとって fault tolerance は2つの理由から重要である。</p>
<ul>
<li>ストリーム処理システムは stateful な計算を終わりのないデータに対して行っている
<ul>
<li>fault tolerance がなければ、障害があったときに最初から状態を計算しなおさなければならない</li>
<li>一方で、多くの場合過去に処理されたデータは既に失われている</li>
</ul>
</li>
<li>最近のストリーム処理システムは分散アーキテクチャを採用している
<ul>
<li>物理マシンの数だけ問題が起こりやすくなる</li>
</ul>
</li>
</ul>
<p>output commit problem についても考慮する必要がある。<br>
これは出力が公開された位置から状態を復元できることが確かな場合のみ、システムは外界に出力を公開するというもの。<br>
言い換えると、障害からの復旧時などに同じ出力を2回してしまわない、出力を <em>exactly-once</em> にできるかというものである。</p>
<h3 id="high-availability">High Availability</h3>
<p>過去の研究においてストリーム処理システムの可用性は recovery time, performance overhead (throughput &amp; latency), resource utilization により定量化されてきた。<br>
この論文では</p>
<blockquote>
<p><em>A streaming system is available when it can provide output based on the processing of its current input.</em></p>
</blockquote>
<p>を可用性の定義として提案する。<br>
時間ごとの processing time と event time の差により定量化される。</p>
<h3 id="apache-flink-の場合-2">Apache Flink の場合</h3>
<h4 id="fault-tolerance-1">Fault Tolerance</h4>
<p>論文中では Flink は output commit problem については Kafka などの出力先の外部システムの責任とするスタンスだとしている。<br>
Kafka には <a href="https://cwiki.apache.org/confluence/display/KAFKA/Idempotent+Producer">idempotent producer</a> という機能があり、たぶんこれのことを言っている。</p>
<p>また一方で <code>TwoPhaseCommitSinkFunction</code> の2相コミットによって <em>exectly-once</em> semantics を提供するという方法も示されている。</p>
<ul>
<li><a href="https://flink.apache.org/features/2018/03/01/end-to-end-exactly-once-apache-flink.html">An Overview of End-to-End Exactly-Once Processing in Apache Flink (with Apache Kafka, too!)</a></li>
</ul>
<p>checkpointing における JobManager を2相コミットの coordinator とみなし、checkpoint barrier が最後の operator に到達するまでをコミット要求相、その後の JobManager からの checkpointing 完了通知をコミット相としている。<br>
コミット相において外部システムへの書き出しの transaction が完了する形となる。</p>
<p>fault tolerance については State Management の項も参照。</p>
<h4 id="high-availability-1">High Availability</h4>
<p>Flink のプロセスには <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/flink-architecture.html#anatomy-of-a-flink-cluster">JobManager と TaskManager</a> があり、前者は cluster に1つだけ動く。<br>
したがって JobManager が SPOF になり、可用性に影響しうる。</p>
<p>high availability (高可用性) を実現するためには JobManager が SPOF となることを避けることができる。<br>
standalone または YARN の cluster として deploy した場合は JobManager が SPOF となることを避けることができる。</p>
<p>以下は standalone の例。<br>
1つの JobManager が leader として動いているが、それが crash すると standby のインスタンスが leader を引き継ぐ。<br>
(論文中では passive replication として紹介)</p>


<figure class="center">
<img
class="mb-2 mx-auto leading-none shadow-xl"
src="/image/flink/jobmanager_ha_overview.png"
alt="Apache Flink">
<figcaption class="text-sm text-right text-raven-500">
<p>Apache Flink <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/jobmanager_high_availability.html#standalone-cluster-high-availability">Standalone Cluster High Availability</a></p>
</figcaption>
</figure>

<h2 id="load-management-elasticity--reconfiguration">Load Management, Elasticity &amp; Reconfiguration</h2>
<h3 id="load-management">Load Management</h3>
<p>ストリーム処理システムは、外部のデータソースがデータを送る流速を制御することができない。<br>
入力データの流速がシステムのキャパより大きいことによるパフォーマンス劣化を防ぐための対応が必要となる。<br>
次のような手法がある。</p>
<ul>
<li>load shedding
<ul>
<li>多すぎる入力データを落とす方法</li>
</ul>
</li>
<li>back-pressure
<ul>
<li>入力データを落とせないときに buffering と組み合わせて使う</li>
<li>dataflow graph 上に速度制限が波及していく</li>
</ul>
</li>
<li>elasticity
<ul>
<li>分散アーキテクチャと cloud にもとづく方法</li>
<li>いわゆる scale out</li>
</ul>
</li>
</ul>
<h3 id="apache-flink-の場合-3">Apache Flink の場合</h3>
<p>Flink では <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/monitoring/back_pressure.html#back-pressure">back pressure</a> および elasticity の組み合わせとなっている。</p>
<p>back pressure は一時的な入力データの増加に対応する。<br>
各 operator (subtask?) は入出力の buffer を持っており、これにより operator 間の処理速度の違いをある程度吸収できる。<br>
しかし入力データが著しく多くなると</p>
<ol>
<li>ボトルネックとなる operator の処理が滞る</li>
<li>その operator の入力 buffer がいっぱいになる</li>
<li>(ボトルネックではない) 上流の operator の出力 buffer がいっぱいになる</li>
<li>上流の operator の処理が滞る</li>
<li>(以降繰り返し)</li>
</ol>
<p>のように、dataflow graph の上流へ上流へと遅延が波及する。</p>
<p>elasticity の面では、JobManager や TaskManager の追加や削除ができるようになっている。</p>
<ul>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/deployment/cluster_setup.html#adding-jobmanagertaskmanager-instances-to-a-cluster">Adding JobManager/TaskManager Instances to a Cluster</a></li>
</ul>
<p>TaskManager の追加や削除においては状態の再配分が行われる。<br>
再配分される状態は key group という単位で partitioning されており、consistent hash 的な方法で各 TaskManager 配下の operator へと配分される。</p>
<p>ちなみに AWS が提供する Flink の managed service である Amazon Kinesis Data Analytics for Apache Flink では CPU 使用率をモニタリングして自動的に scale out が行われるようになっている。</p>
<ul>
<li><a href="https://docs.aws.amazon.com/kinesisanalytics/latest/java/how-scaling.html">Application Scaling in Kinesis Data Analytics for Apache Flink</a></li>
</ul>
<h2 id="まとめ">まとめ</h2>
<p>バッチ処理ではあまりクリティカルにならないような問題でもストリーム処理では重大な影響を及ぼすことがある。<br>
ストリーム処理に求められる機能性を実現するに当たり、Apache Flink では checkpoint の仕組みが中心的な役割を果たしているということが理解できた。</p>

      </article>
      

      

    </div>
  </div>
</div>

  </main>
  <footer class="footer">
  <div class="ax-l-i max-w-6xl">
    <nav class="flex items-center justify-center">
      <a class="ml-3 first:ml-0 text-sm text-gray-600 hover:text-gray-800" href="/posts/">Posts</a>
      <a class="ml-3 first:ml-0 text-sm text-gray-600 hover:text-gray-800" href="/tags/">Tags</a>
      <a class="ml-3 first:ml-0 text-sm text-gray-600 hover:text-gray-800" href="/about/">About</a>
    </nav>
    <div class="footer-social flex items-center justify-center mt-4">
      <a class="block mx-3 w-6 h-6 text-raven-700 hover:text-raven-900" target="_blank" rel="noopener nofollow" title="Twitter" href="https://twitter.com/soonraah"><svg class="fill-current" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M32 6.078c-1.2.522-2.458.868-3.78 1.036 1.36-.812 2.398-2.088 2.886-3.626a13.11 13.11 0 0 1-4.16 1.588C25.742 3.794 24.026 3 22.154 3a6.56 6.56 0 0 0-6.556 6.562c0 .52.044 1.02.152 1.496-5.454-.266-10.28-2.88-13.522-6.862-.566.982-.898 2.106-.898 3.316a6.57 6.57 0 0 0 2.914 5.452 6.48 6.48 0 0 1-2.964-.808v.072c0 3.188 2.274 5.836 5.256 6.446-.534.146-1.116.216-1.72.216-.42 0-.844-.024-1.242-.112.85 2.598 3.262 4.508 6.13 4.57a13.18 13.18 0 0 1-8.134 2.798c-.538 0-1.054-.024-1.57-.1C2.906 27.93 6.35 29 10.064 29c12.072 0 18.672-10 18.672-18.668 0-.3-.01-.57-.024-.848C30.014 8.56 31.108 7.406 32 6.078z"/></svg></a>
      <a class="block mx-3 w-6 h-6 text-raven-700 hover:text-raven-900" target="_blank" rel="noopener nofollow" title="Github" href="https://github.com/soonraah"><svg class="fill-current" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M15.998 0C7.164 0 0 7.35 0 16.417 0 23.67 4.584 29.82 10.944 31.994c.8.15 1.092-.356 1.092-.79l-.022-2.792c-4.45.99-5.4-2.202-5.4-2.202-.726-1.896-1.776-2.4-1.776-2.4-1.454-1.018.108-.998.108-.998 1.606.117 2.45 1.693 2.45 1.693 1.428 2.507 3.746 1.784 4.658 1.363.144-1.06.558-1.784 1.016-2.195-3.552-.415-7.288-1.823-7.288-8.113 0-1.792.624-3.258 1.648-4.406-.166-.415-.714-2.085.156-4.344 0 0 1.344-.44 4.4 1.683 1.276-.364 2.644-.546 4.006-.552a14.98 14.98 0 0 1 4.006.554C23.062 6.37 24.404 6.8 24.404 6.8c.872 2.26.324 3.93.16 4.344 1.026 1.148 1.644 2.614 1.644 4.406 0 6.306-3.74 7.694-7.304 8.1.574.507 1.086 1.51 1.086 3.04l-.02 4.503c0 .44.288.95 1.1.788C27.42 29.817 32 23.667 32 16.417 32 7.35 24.836 0 15.998 0z"/></svg></a>
    </div>

    <div class="footer-copyright text-sm text-center text-gray-500 mt-4">
      &#169; 2020-2020 Froglog
    </div>
    <div class="text-sm sm:text-xs text-center text-gray-500 mt-2">
      Powered by <a href="https://www.axiomtheme.com/?utm_source=theme-footer&utm_medium=website&utm_campaign=referral">Axiom</a>
    </div>
  </div>
</footer>

<script src="/bundle.js?v=1604733798"></script>


</body>
</html>
