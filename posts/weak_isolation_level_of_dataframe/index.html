<!doctype html><html lang=ja dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Spark DataFrame クエリの弱い分離レベル | Froglog</title>
<meta name=keywords content="Apache Spark,transaction">
<meta name=description content="Spark バッチ処理の問題を調べていたら分離レベルという概念にたどりついた。
分離レベルについて調べたので、Spark の問題の内容と絡めて記しておく。
考えてみれば当たり前でたいした話ではない。
分離レベルとは トランザクションの挙動についての暗黙の理解 アドホックな分析クエリやプロダクションコード中のクエリを書くとき、その単一のクエリのトランザクションにおいて「同時に実行されている別のクエリの commit 前の状態や commit 結果に影響され、このクエリの結果がおかしくなるかもしれない」ということは通常考えない。
トランザクションはデータベースのある時点の状態に対して正しく処理される、というほぼ無意識の理解をおそらくほとんどの開発者が持っている。
多くの場合この理解は間違っていない。
それはなぜかというと DB 等のデータ処理フレームワークがある強さの分離レベルを提供しているからである。
いろいろな分離レベル ACID 特性のうちの1つ、分離性 (Isolation) の程度を表すのが分離レベル。
 トランザクション中に行われる操作の過程が他の操作から隠蔽されることを指し、日本語では分離性、独立性または隔離性ともいう。より形式的には、独立性とはトランザクション履歴が直列化されていることと言える。この性質と性能はトレードオフの関係にあるため、一般的にはこの性質の一部を緩和して実装される場合が多い。 &ndash; Wikipedia ACID (コンピュータ科学) 分離レベルには名前のついたものがいくつかあり、分離性の保証の強さが異なる。
具体的にはトランザクションの並行性の問題への対応力が異なる。
名著「データ指向アプリケーションデザイン」の第7章で分離レベルについて詳しく述べられているので、以下ではそちらからの引用。
分離レベルを弱い順に並べる。
  read uncommitted
 このレベルではダーティライトは生じませんが、ダーティリードは妨げられません。
   read committed
  データベースからの読み取りを行った際に見えるデータは、コミットされたもののみであること（ダーティリードは生じない）。 データベースへの書き込みを行う場合、上書きするのはコミットされたデータのみであること（ダーティライトは生じない）。     snapshot isolation
 スナップショット分離の考え方は、それぞれのトランザクションがデータベースの一貫性のあるスナップショットから読み取りを行うというものです。すなわち、トランザクションが読み取るデータは、すべてそのトランザクションの開始時点のデータベースにコミット済みのものだけということです。
   serializability
 この分離レベルはトランザクションが並行して実行されていても、最終的な答えはそれぞれが1つずつ順番に、並行ではなく実行された場合と同じになることを保証します。
   日本語で「分離レベル」を検索すると snapshot isolation の代わりに repeatable read が出てくる事が多い。">
<meta name=author content="soonraah">
<link rel=canonical href=https://soonraah.github.io/posts/weak_isolation_level_of_dataframe/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.ec8da366ca2fb647537ccb7a8f6fa5b4e9cd3c7a0d3171dd2d3baad1e49c8bfc.css integrity="sha256-7I2jZsovtkdTfMt6j2+ltOnNPHoNMXHdLTuq0eSci/w=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://soonraah.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://soonraah.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://soonraah.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://soonraah.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://soonraah.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-73329599-2','auto'),ga('send','pageview'))</script><meta property="og:title" content="Spark DataFrame クエリの弱い分離レベル">
<meta property="og:description" content="Spark バッチ処理の問題を調べていたら分離レベルという概念にたどりついた。
分離レベルについて調べたので、Spark の問題の内容と絡めて記しておく。
考えてみれば当たり前でたいした話ではない。
分離レベルとは トランザクションの挙動についての暗黙の理解 アドホックな分析クエリやプロダクションコード中のクエリを書くとき、その単一のクエリのトランザクションにおいて「同時に実行されている別のクエリの commit 前の状態や commit 結果に影響され、このクエリの結果がおかしくなるかもしれない」ということは通常考えない。
トランザクションはデータベースのある時点の状態に対して正しく処理される、というほぼ無意識の理解をおそらくほとんどの開発者が持っている。
多くの場合この理解は間違っていない。
それはなぜかというと DB 等のデータ処理フレームワークがある強さの分離レベルを提供しているからである。
いろいろな分離レベル ACID 特性のうちの1つ、分離性 (Isolation) の程度を表すのが分離レベル。
 トランザクション中に行われる操作の過程が他の操作から隠蔽されることを指し、日本語では分離性、独立性または隔離性ともいう。より形式的には、独立性とはトランザクション履歴が直列化されていることと言える。この性質と性能はトレードオフの関係にあるため、一般的にはこの性質の一部を緩和して実装される場合が多い。 &ndash; Wikipedia ACID (コンピュータ科学) 分離レベルには名前のついたものがいくつかあり、分離性の保証の強さが異なる。
具体的にはトランザクションの並行性の問題への対応力が異なる。
名著「データ指向アプリケーションデザイン」の第7章で分離レベルについて詳しく述べられているので、以下ではそちらからの引用。
分離レベルを弱い順に並べる。
  read uncommitted
 このレベルではダーティライトは生じませんが、ダーティリードは妨げられません。
   read committed
  データベースからの読み取りを行った際に見えるデータは、コミットされたもののみであること（ダーティリードは生じない）。 データベースへの書き込みを行う場合、上書きするのはコミットされたデータのみであること（ダーティライトは生じない）。     snapshot isolation
 スナップショット分離の考え方は、それぞれのトランザクションがデータベースの一貫性のあるスナップショットから読み取りを行うというものです。すなわち、トランザクションが読み取るデータは、すべてそのトランザクションの開始時点のデータベースにコミット済みのものだけということです。
   serializability
 この分離レベルはトランザクションが並行して実行されていても、最終的な答えはそれぞれが1つずつ順番に、並行ではなく実行された場合と同じになることを保証します。
   日本語で「分離レベル」を検索すると snapshot isolation の代わりに repeatable read が出てくる事が多い。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://soonraah.github.io/posts/weak_isolation_level_of_dataframe/"><meta property="og:image" content="https://soonraah.github.io/47"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2020-07-19T22:00:00+09:00">
<meta property="article:modified_time" content="2020-07-19T22:00:00+09:00"><meta property="og:site_name" content="Froglog">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://soonraah.github.io/47">
<meta name=twitter:title content="Spark DataFrame クエリの弱い分離レベル">
<meta name=twitter:description content="Spark バッチ処理の問題を調べていたら分離レベルという概念にたどりついた。
分離レベルについて調べたので、Spark の問題の内容と絡めて記しておく。
考えてみれば当たり前でたいした話ではない。
分離レベルとは トランザクションの挙動についての暗黙の理解 アドホックな分析クエリやプロダクションコード中のクエリを書くとき、その単一のクエリのトランザクションにおいて「同時に実行されている別のクエリの commit 前の状態や commit 結果に影響され、このクエリの結果がおかしくなるかもしれない」ということは通常考えない。
トランザクションはデータベースのある時点の状態に対して正しく処理される、というほぼ無意識の理解をおそらくほとんどの開発者が持っている。
多くの場合この理解は間違っていない。
それはなぜかというと DB 等のデータ処理フレームワークがある強さの分離レベルを提供しているからである。
いろいろな分離レベル ACID 特性のうちの1つ、分離性 (Isolation) の程度を表すのが分離レベル。
 トランザクション中に行われる操作の過程が他の操作から隠蔽されることを指し、日本語では分離性、独立性または隔離性ともいう。より形式的には、独立性とはトランザクション履歴が直列化されていることと言える。この性質と性能はトレードオフの関係にあるため、一般的にはこの性質の一部を緩和して実装される場合が多い。 &ndash; Wikipedia ACID (コンピュータ科学) 分離レベルには名前のついたものがいくつかあり、分離性の保証の強さが異なる。
具体的にはトランザクションの並行性の問題への対応力が異なる。
名著「データ指向アプリケーションデザイン」の第7章で分離レベルについて詳しく述べられているので、以下ではそちらからの引用。
分離レベルを弱い順に並べる。
  read uncommitted
 このレベルではダーティライトは生じませんが、ダーティリードは妨げられません。
   read committed
  データベースからの読み取りを行った際に見えるデータは、コミットされたもののみであること（ダーティリードは生じない）。 データベースへの書き込みを行う場合、上書きするのはコミットされたデータのみであること（ダーティライトは生じない）。     snapshot isolation
 スナップショット分離の考え方は、それぞれのトランザクションがデータベースの一貫性のあるスナップショットから読み取りを行うというものです。すなわち、トランザクションが読み取るデータは、すべてそのトランザクションの開始時点のデータベースにコミット済みのものだけということです。
   serializability
 この分離レベルはトランザクションが並行して実行されていても、最終的な答えはそれぞれが1つずつ順番に、並行ではなく実行された場合と同じになることを保証します。
   日本語で「分離レベル」を検索すると snapshot isolation の代わりに repeatable read が出てくる事が多い。">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://soonraah.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Spark DataFrame クエリの弱い分離レベル","item":"https://soonraah.github.io/posts/weak_isolation_level_of_dataframe/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Spark DataFrame クエリの弱い分離レベル","name":"Spark DataFrame クエリの弱い分離レベル","description":"Spark バッチ処理の問題を調べていたら分離レベルという概念にたどりついた。\n分離レベルについて調べたので、Spark の問題の内容と絡めて記しておく。\n考えてみれば当たり前でたいした話ではない。\n分離レベルとは トランザクションの挙動についての暗黙の理解 アドホックな分析クエリやプロダクションコード中のクエリを書くとき、その単一のクエリのトランザクションにおいて「同時に実行されている別のクエリの commit 前の状態や commit 結果に影響され、このクエリの結果がおかしくなるかもしれない」ということは通常考えない。\nトランザクションはデータベースのある時点の状態に対して正しく処理される、というほぼ無意識の理解をおそらくほとんどの開発者が持っている。\n多くの場合この理解は間違っていない。\nそれはなぜかというと DB 等のデータ処理フレームワークがある強さの分離レベルを提供しているからである。\nいろいろな分離レベル ACID 特性のうちの1つ、分離性 (Isolation) の程度を表すのが分離レベル。\n トランザクション中に行われる操作の過程が他の操作から隠蔽されることを指し、日本語では分離性、独立性または隔離性ともいう。より形式的には、独立性とはトランザクション履歴が直列化されていることと言える。この性質と性能はトレードオフの関係にあるため、一般的にはこの性質の一部を緩和して実装される場合が多い。 \u0026ndash; Wikipedia ACID (コンピュータ科学) 分離レベルには名前のついたものがいくつかあり、分離性の保証の強さが異なる。\n具体的にはトランザクションの並行性の問題への対応力が異なる。\n名著「データ指向アプリケーションデザイン」の第7章で分離レベルについて詳しく述べられているので、以下ではそちらからの引用。\n分離レベルを弱い順に並べる。\n  read uncommitted\n このレベルではダーティライトは生じませんが、ダーティリードは妨げられません。\n   read committed\n  データベースからの読み取りを行った際に見えるデータは、コミットされたもののみであること（ダーティリードは生じない）。 データベースへの書き込みを行う場合、上書きするのはコミットされたデータのみであること（ダーティライトは生じない）。     snapshot isolation\n スナップショット分離の考え方は、それぞれのトランザクションがデータベースの一貫性のあるスナップショットから読み取りを行うというものです。すなわち、トランザクションが読み取るデータは、すべてそのトランザクションの開始時点のデータベースにコミット済みのものだけということです。\n   serializability\n この分離レベルはトランザクションが並行して実行されていても、最終的な答えはそれぞれが1つずつ順番に、並行ではなく実行された場合と同じになることを保証します。\n   日本語で「分離レベル」を検索すると snapshot isolation の代わりに repeatable read が出てくる事が多い。","keywords":["Apache Spark","transaction"],"articleBody":"Spark バッチ処理の問題を調べていたら分離レベルという概念にたどりついた。\n分離レベルについて調べたので、Spark の問題の内容と絡めて記しておく。\n考えてみれば当たり前でたいした話ではない。\n分離レベルとは トランザクションの挙動についての暗黙の理解 アドホックな分析クエリやプロダクションコード中のクエリを書くとき、その単一のクエリのトランザクションにおいて「同時に実行されている別のクエリの commit 前の状態や commit 結果に影響され、このクエリの結果がおかしくなるかもしれない」ということは通常考えない。\nトランザクションはデータベースのある時点の状態に対して正しく処理される、というほぼ無意識の理解をおそらくほとんどの開発者が持っている。\n多くの場合この理解は間違っていない。\nそれはなぜかというと DB 等のデータ処理フレームワークがある強さの分離レベルを提供しているからである。\nいろいろな分離レベル ACID 特性のうちの1つ、分離性 (Isolation) の程度を表すのが分離レベル。\n トランザクション中に行われる操作の過程が他の操作から隠蔽されることを指し、日本語では分離性、独立性または隔離性ともいう。より形式的には、独立性とはトランザクション履歴が直列化されていることと言える。この性質と性能はトレードオフの関係にあるため、一般的にはこの性質の一部を緩和して実装される場合が多い。 – Wikipedia ACID (コンピュータ科学) 分離レベルには名前のついたものがいくつかあり、分離性の保証の強さが異なる。\n具体的にはトランザクションの並行性の問題への対応力が異なる。\n名著「データ指向アプリケーションデザイン」の第7章で分離レベルについて詳しく述べられているので、以下ではそちらからの引用。\n分離レベルを弱い順に並べる。\n  read uncommitted\n このレベルではダーティライトは生じませんが、ダーティリードは妨げられません。\n   read committed\n  データベースからの読み取りを行った際に見えるデータは、コミットされたもののみであること（ダーティリードは生じない）。 データベースへの書き込みを行う場合、上書きするのはコミットされたデータのみであること（ダーティライトは生じない）。     snapshot isolation\n スナップショット分離の考え方は、それぞれのトランザクションがデータベースの一貫性のあるスナップショットから読み取りを行うというものです。すなわち、トランザクションが読み取るデータは、すべてそのトランザクションの開始時点のデータベースにコミット済みのものだけということです。\n   serializability\n この分離レベルはトランザクションが並行して実行されていても、最終的な答えはそれぞれが1つずつ順番に、並行ではなく実行された場合と同じになることを保証します。\n   日本語で「分離レベル」を検索すると snapshot isolation の代わりに repeatable read が出てくる事が多い。\nしかし repeatable read の名前は実装によって意味が違っていたりして扱いが難しいらしい。\n分離レベルと race condition の関係 以下に各分離レベルとトランザクションの並行性の問題 (race condition) の関係を示す。\n各 race condition の説明については割愛するが、複数のトランザクションが並行して実行されることにより起こりうる期待されていない挙動だと思えばよい。\n○はその分離レベルにおいてその race condition が発生しないことを示す。\n△は条件によっては発生する。\n    dirty read dirty write read skew (nonrepeatable read) lost update write skew phantom read     read uncommitted ○ - - - - -   read committed ○ ○ - - - -   snapshot isolation ○ ○ ○ △ - △   serializability ○ ○ ○ ○ ○ ○    下に行くほど強い分離レベルとなっている。\n分離レベルが強くなるほど race condition が発生しにくくなるが、一方で lock 等によりパフォーマンスが下がっていくというトレードオフがある。\n各種データベースの分離レベル ここでは MySQL と Hive においてどの分離レベルが提供されているかを見てみる。\nMySQL の場合 MySQL の分離レベルについては以下のドキュメントで述べられている。\n 15.7.2.1 Transaction Isolation Levels  MySQL (というか InnoDB?) では次の4つの分離レベルを設定することができる。\n READ UNCOMMITTED READ COMMITTED REPEATABLE READ (default) SERIALIZABLE  デフォルトの分離レベルは REPEATABLE READ だが、これは前述の snapshot isolation に相当するらしい。\n分離レベルは、例えば set transaction 構文により次のようにして指定できる。\nset transaction isolation level SERIALIZABLE; この場合は現在のセッション内で実行される次のトランザクションについて適用される。\nすべてのセッションやすべてのトランザクション等の指定もできる。\n詳しくは以下。\n 13.3.7 SET TRANSACTION Statement  Hive の場合 Hive についてはドキュメントに次のような記載がある。\n At this time only snapshot level isolation is supported. When a given query starts it will be provided with a consistent snapshot of the data.– Hive Transactions Hive は snapshot isolation のみ提供しているとのこと。\n The default DummyTxnManager emulates behavior of old Hive versions: has no transactions and uses hive.lock.manager property to create lock manager for tables, partitions and databases.– Hive Transactions lock は小さくとも partition の単位になるのだろうか。\nであるとすると予想通りだが MySQL よりもいかつい挙動になっている。\nこのように多くの DB では snapshot isolation の分離レベルが基本となっている。\nSpark クエリの分離レベル では Spark のクエリはどうだろうか。\nここからようやく本題となる。\nread committed 相当 Spark において DataFrame を用いたデータ処理を記述するとき、それは1つの SQL クエリを書くのと近い感覚になる。\nそもそも DataFrame は SQL-like な使い心地を目的として作られた API だから当然だ。\nDataFrame で記述された処理は実行時に RDD として翻訳されるが、分離レベルを考えるにあたって RDD の特性がキーとなってくる。\n By default, each transformed RDD may be recomputed each time you run an action on it.– RDD Operations あまり良い説明を見つけられなかったが、1回の action を伴う処理においても同じ RDD が複数回参照されるとき、その RDD までの計算は通常やり直されることになる。\nしたがって例えば self join のようなことをするとき、同じデータソースを2回読みに行くということが起こってしまう。\nHDFS や S3 上のファイル、JDBC 経由の外部 DB など Spark は様々なデータソースを扱うことができるが、通常 Spark がその2回の読み込みに対して lock をかけたりすることはできない。\nつまり non-repeatable read や phantom read を防ぐことができない。\nread committed という弱い分離レベルに相当するということになってしまう。\n分離レベルという言葉はトランザクションという概念に対して使われるものであり、DataFrame のクエリをトランザクションと呼んでいいのかはわからない。\nなので分離レベルという言葉をここで使うのが適切でないかもしれないということは述べておく。\n検証 MySQL からデータを読み取り Spark で処理することを考える。\nまず local の MySQL で次のような table を用意する。\nmysql describe employees; +---------------+---------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +---------------+---------+------+-----+---------+-------+ | id | int(11) | NO | PRI | NULL | | | salary | int(11) | YES | | NULL | | | department_id | int(11) | YES | | NULL | | +---------------+---------+------+-----+---------+-------+ 3 rows in set (0.03 sec) 部署 (department) ごとの給料 (salary) の平均から各従業員の給料がどれくらい離れているかの差分を見たいものとする。\nSpark のコードは次のようになる。\nSpark のバージョンはこれを書いている時点での最新 3.0.0 とした。\npackage com.example import org.apache.spark.sql.functions.avg import org.apache.spark.sql.SparkSession object IsolationLevelExperiment { def main(args: Array[String]): Unit = { // Prepare SparkSession  val spark = SparkSession .builder() .appName(\"Isolation Level Experiment\") .master(\"local[*]\") .getOrCreate() import spark.implicits._ // Read from MySQL  val dfEmployee = spark .read .format(\"jdbc\") .option(\"url\", \"jdbc:mysql://localhost\") .option(\"dbtable\", \"db_name.employees\") .option(\"user\", \"user_name\") .option(\"password\", \"********\") .option(\"driver\", \"com.mysql.cj.jdbc.Driver\") .load .cache // Get average salary  val dfAvg = dfEmployee .groupBy($\"department_id\") .agg(avg($\"salary\").as(\"avg_salary\")) // Calculate diff  val dfResult = dfEmployee .as(\"e\") .join( dfAvg.as(\"a\"), $\"e.department_id\" === $\"a.department_id\", \"left_outer\" ) .select( $\"e.id\", $\"e.department_id\", ($\"e.salary\" - $\"a.avg_salary\").as(\"salary_diff\") ) // Output results  dfResult.show spark.stop() } } このコードを実行する前に MySQL の general query log を ON にする。\nmysql set global general_log = 'ON'; Query OK, 0 rows affected (0.02 sec) mysql show global variables like 'general_log%'; +------------------+--------------------------------------+ | Variable_name | Value | +------------------+--------------------------------------+ | general_log | ON | | general_log_file | /usr/local/var/mysql/MacBook-Pro.log | +------------------+--------------------------------------+ 2 rows in set (0.01 sec) これによって MySQL に対して発行されたクエリがログとして記録されるようになる。\n直感的に snapshot isolation になっているのであれば MySQL に対する select 文は1回だけ発行されるはずである。\nしかし前述のとおり RDD や DataFrame の処理は途中の状態を通常保存せず、同じ RDD や DataFrame を参照していたとしても再計算される。\n上記コードの例だと dfEmployee が2回参照されている。\nコードを実行すると general query log には次のように、データ取得のための select 文が2つ記録されていた。\nそれぞれ join() の左右の table のデータソースを示している。\n8 Query SELECT `id`,`salary`,`department_id` FROM test_fout_dsp.employees 7 Query SELECT `salary`,`department_id` FROM test_fout_dsp.employees WHERE (`department_id` IS NOT NULL) 2つの select 文はそれぞれ別のクエリ、トランザクションとして発行されている。\nしたがって前者の select 文が実行された後、後者の select 文が実行される前に別のトランザクションにより employees が更新されたり挿入・削除されたりすると non-repeatable read や phantom read が発生してしまうのである。\n今回はデータソースへのアクセスを確認するためにデータソースとして MySQL を使ったが、同じことはファイルや他の DB など別のデータソースで起こりうる。\n回避策 プロダクト運用上、non-repeatable read や phantom read が発生しうる状況というのは多くの場合で厄介である。\n一時的なデータソースの状態に依存して問題が発生するため、バグの原因追求がとても困難だからだ。\n見た目上の分離レベルを強くし、これらを避けるには2つの方法が考えられる。\nimmutable なデータにのみアクセスする 単純な話で non-repeatable read や phantom read が発生するようなデータソースを参照しなければよい。\n例えばユーザの行動ログのような蓄積されていくデータが hour 単位で partitioning されているような場合、基本的に過去の partition に対しては変更や挿入・削除は行われない。\nこのような partition にアクセスする分には前述のような厄介な問題は起こらない。\ncache する データソースから読み取った結果の DataFrame に対して cache() または persist() をするとよい。\n Spark SQL can cache tables using an in-memory columnar format by calling spark.catalog.cacheTable(\"tableName\") or dataFrame.cache().– Caching Data In Memory 前述のコードで dfEmployee に対して .cache() をした場合、MySQL へのデータ取得のための select 文の発行は1回になった。\n大きなデータソースを cache() するときだけメモリや HDD 容量に気をつけておきたい。\nまとめ DataFrame はいわゆる RDBMS を操作しているように見えてしまうところが難しいところだろうか。\n「データ指向アプリケーションデザイン」に至極真っ当なことが書いてあったので、その言葉を借りて締めておく。\n 何も考えずにツールを信じて依存するのではなく、並行性の問題にはどういったものがあるのか、そしてそれらを回避するにはどうしたら良いのかを、しっかり理解しなければなりません。そうすれば、信頼性があり、正しく動作するアプリケーションを手の届くツールを使って構築できるようになります。– Martin Kleppmann データ指向アプリケーションデザイン ","wordCount":"708","inLanguage":"ja","datePublished":"2020-07-19T22:00:00+09:00","dateModified":"2020-07-19T22:00:00+09:00","author":{"@type":"Person","name":"soonraah"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://soonraah.github.io/posts/weak_isolation_level_of_dataframe/"},"publisher":{"@type":"Organization","name":"Froglog","logo":{"@type":"ImageObject","url":"https://soonraah.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://soonraah.github.io accesskey=h title="Home (Alt + H)">
<img src=https://soonraah.github.io/image/brand/favicon.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://soonraah.github.io/about/ title=About>
<span>About</span>
</a>
</li>
<li>
<a href=https://soonraah.github.io/posts/ title=Posts>
<span>Posts</span>
</a>
</li>
<li>
<a href=https://soonraah.github.io/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://soonraah.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://soonraah.github.io/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://soonraah.github.io>Home</a>&nbsp;»&nbsp;<a href=https://soonraah.github.io/posts/>Posts</a></div>
<h1 class=post-title>
Spark DataFrame クエリの弱い分離レベル
</h1>
<div class=post-meta><span title="2020-07-19 22:00:00 +0900 JST">7月 19, 2020</span>&nbsp;·&nbsp;soonraah
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>目次</span>
</summary>
<div class=inner><ul>
<li>
<a href=#%e5%88%86%e9%9b%a2%e3%83%ac%e3%83%99%e3%83%ab%e3%81%a8%e3%81%af aria-label=分離レベルとは>分離レベルとは</a><ul>
<li>
<a href=#%e3%83%88%e3%83%a9%e3%83%b3%e3%82%b6%e3%82%af%e3%82%b7%e3%83%a7%e3%83%b3%e3%81%ae%e6%8c%99%e5%8b%95%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6%e3%81%ae%e6%9a%97%e9%bb%99%e3%81%ae%e7%90%86%e8%a7%a3 aria-label=トランザクションの挙動についての暗黙の理解>トランザクションの挙動についての暗黙の理解</a></li>
<li>
<a href=#%e3%81%84%e3%82%8d%e3%81%84%e3%82%8d%e3%81%aa%e5%88%86%e9%9b%a2%e3%83%ac%e3%83%99%e3%83%ab aria-label=いろいろな分離レベル>いろいろな分離レベル</a></li>
<li>
<a href=#%e5%88%86%e9%9b%a2%e3%83%ac%e3%83%99%e3%83%ab%e3%81%a8-race-condition-%e3%81%ae%e9%96%a2%e4%bf%82 aria-label="分離レベルと race condition の関係">分離レベルと race condition の関係</a></li></ul>
</li>
<li>
<a href=#%e5%90%84%e7%a8%ae%e3%83%87%e3%83%bc%e3%82%bf%e3%83%99%e3%83%bc%e3%82%b9%e3%81%ae%e5%88%86%e9%9b%a2%e3%83%ac%e3%83%99%e3%83%ab aria-label=各種データベースの分離レベル>各種データベースの分離レベル</a><ul>
<li>
<a href=#mysql-%e3%81%ae%e5%a0%b4%e5%90%88 aria-label="MySQL の場合">MySQL の場合</a></li>
<li>
<a href=#hive-%e3%81%ae%e5%a0%b4%e5%90%88 aria-label="Hive の場合">Hive の場合</a></li></ul>
</li>
<li>
<a href=#spark-%e3%82%af%e3%82%a8%e3%83%aa%e3%81%ae%e5%88%86%e9%9b%a2%e3%83%ac%e3%83%99%e3%83%ab aria-label="Spark クエリの分離レベル">Spark クエリの分離レベル</a><ul>
<li>
<a href=#read-committed-%e7%9b%b8%e5%bd%93 aria-label="read committed 相当">read committed 相当</a></li>
<li>
<a href=#%e6%a4%9c%e8%a8%bc aria-label=検証>検証</a></li>
<li>
<a href=#%e5%9b%9e%e9%81%bf%e7%ad%96 aria-label=回避策>回避策</a><ul>
<li>
<a href=#immutable-%e3%81%aa%e3%83%87%e3%83%bc%e3%82%bf%e3%81%ab%e3%81%ae%e3%81%bf%e3%82%a2%e3%82%af%e3%82%bb%e3%82%b9%e3%81%99%e3%82%8b aria-label="immutable なデータにのみアクセスする">immutable なデータにのみアクセスする</a></li>
<li>
<a href=#cache-%e3%81%99%e3%82%8b aria-label="cache する">cache する</a></li></ul>
</li></ul>
</li>
<li>
<a href=#%e3%81%be%e3%81%a8%e3%82%81 aria-label=まとめ>まとめ</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p>Spark バッチ処理の問題を調べていたら分離レベルという概念にたどりついた。<br>
分離レベルについて調べたので、Spark の問題の内容と絡めて記しておく。<br>
考えてみれば当たり前でたいした話ではない。</p>
<h1 id=分離レベルとは>分離レベルとは<a hidden class=anchor aria-hidden=true href=#分離レベルとは>#</a></h1>
<h2 id=トランザクションの挙動についての暗黙の理解>トランザクションの挙動についての暗黙の理解<a hidden class=anchor aria-hidden=true href=#トランザクションの挙動についての暗黙の理解>#</a></h2>
<p>アドホックな分析クエリやプロダクションコード中のクエリを書くとき、その単一のクエリのトランザクションにおいて「同時に実行されている別のクエリの commit 前の状態や commit 結果に影響され、このクエリの結果がおかしくなるかもしれない」ということは通常考えない。<br>
トランザクションはデータベースのある時点の状態に対して正しく処理される、というほぼ無意識の理解をおそらくほとんどの開発者が持っている。</p>
<p>多くの場合この理解は間違っていない。<br>
それはなぜかというと DB 等のデータ処理フレームワークがある強さの分離レベルを提供しているからである。</p>
<h2 id=いろいろな分離レベル>いろいろな分離レベル<a hidden class=anchor aria-hidden=true href=#いろいろな分離レベル>#</a></h2>
<p>ACID 特性のうちの1つ、分離性 (Isolation) の程度を表すのが分離レベル。</p>
<blockquote>
<p>トランザクション中に行われる操作の過程が他の操作から隠蔽されることを指し、日本語では分離性、独立性または隔離性ともいう。より形式的には、独立性とはトランザクション履歴が直列化されていることと言える。この性質と性能はトレードオフの関係にあるため、一般的にはこの性質の一部を緩和して実装される場合が多い。 <br>
&ndash; <a href=https://ja.wikipedia.org/wiki/ACID_(%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E7%A7%91%E5%AD%A6)>Wikipedia ACID (コンピュータ科学)</a></p>
</blockquote>
<p>分離レベルには名前のついたものがいくつかあり、分離性の保証の強さが異なる。<br>
具体的にはトランザクションの並行性の問題への対応力が異なる。<br>
名著「<a href="https://www.amazon.co.jp/gp/product/4873118700/ref=as_li_tl?ie=UTF8&camp=247&creative=1211&creativeASIN=4873118700&linkCode=as2&tag=froglog02-22&linkId=19bf71b38427997bd19423b1bb219d3f">データ指向アプリケーションデザイン</a>」の第7章で分離レベルについて詳しく述べられているので、以下ではそちらからの引用。</p>
<a target=_blank href="https://www.amazon.co.jp/gp/product/4873118700/ref=as_li_tl?ie=UTF8&camp=247&creative=1211&creativeASIN=4873118700&linkCode=as2&tag=froglog02-22&linkId=4d28525a2e352660b372d4d1027b72fb"><img border=0 src="//ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&MarketPlace=JP&ASIN=4873118700&ServiceVersion=20070822&ID=AsinImage&WS=1&Format=_SL250_&tag=froglog02-22"></a><img src="//ir-jp.amazon-adsystem.com/e/ir?t=froglog02-22&l=am2&o=9&a=4873118700" width=1 height=1 border=0 alt style=border:none!important;margin:0!important>
<br>
<p>分離レベルを弱い順に並べる。</p>
<ul>
<li>
<p>read uncommitted</p>
<blockquote>
<p>このレベルではダーティライトは生じませんが、ダーティリードは妨げられません。</p>
</blockquote>
</li>
<li>
<p>read committed</p>
<blockquote>
<ol>
<li>データベースからの読み取りを行った際に見えるデータは、コミットされたもののみであること（ダーティリードは生じない）。</li>
<li>データベースへの書き込みを行う場合、上書きするのはコミットされたデータのみであること（ダーティライトは生じない）。</li>
</ol>
</blockquote>
</li>
<li>
<p>snapshot isolation</p>
<blockquote>
<p>スナップショット分離の考え方は、それぞれのトランザクションがデータベースの一貫性のあるスナップショットから読み取りを行うというものです。すなわち、トランザクションが読み取るデータは、すべてそのトランザクションの開始時点のデータベースにコミット済みのものだけということです。</p>
</blockquote>
</li>
<li>
<p>serializability</p>
<blockquote>
<p>この分離レベルはトランザクションが並行して実行されていても、最終的な答えはそれぞれが1つずつ順番に、並行ではなく実行された場合と同じになることを保証します。</p>
</blockquote>
</li>
</ul>
<p>日本語で「分離レベル」を検索すると snapshot isolation の代わりに repeatable read が出てくる事が多い。<br>
しかし repeatable read の名前は実装によって意味が違っていたりして扱いが難しいらしい。</p>
<h2 id=分離レベルと-race-condition-の関係>分離レベルと race condition の関係<a hidden class=anchor aria-hidden=true href=#分離レベルと-race-condition-の関係>#</a></h2>
<p>以下に各分離レベルとトランザクションの並行性の問題 (race condition) の関係を示す。<br>
各 race condition の説明については割愛するが、複数のトランザクションが並行して実行されることにより起こりうる期待されていない挙動だと思えばよい。<br>
○はその分離レベルにおいてその race condition が発生しないことを示す。<br>
△は条件によっては発生する。</p>
<table>
<thead>
<tr>
<th></th>
<th>dirty read</th>
<th>dirty write</th>
<th>read skew (nonrepeatable read)</th>
<th>lost update</th>
<th>write skew</th>
<th>phantom read</th>
</tr>
</thead>
<tbody>
<tr>
<td>read uncommitted</td>
<td>○</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>read committed</td>
<td>○</td>
<td>○</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>snapshot isolation</td>
<td>○</td>
<td>○</td>
<td>○</td>
<td>△</td>
<td>-</td>
<td>△</td>
</tr>
<tr>
<td>serializability</td>
<td>○</td>
<td>○</td>
<td>○</td>
<td>○</td>
<td>○</td>
<td>○</td>
</tr>
</tbody>
</table>
<p>下に行くほど強い分離レベルとなっている。<br>
分離レベルが強くなるほど race condition が発生しにくくなるが、一方で lock 等によりパフォーマンスが下がっていくというトレードオフがある。</p>
<h1 id=各種データベースの分離レベル>各種データベースの分離レベル<a hidden class=anchor aria-hidden=true href=#各種データベースの分離レベル>#</a></h1>
<p>ここでは MySQL と Hive においてどの分離レベルが提供されているかを見てみる。</p>
<h2 id=mysql-の場合>MySQL の場合<a hidden class=anchor aria-hidden=true href=#mysql-の場合>#</a></h2>
<p>MySQL の分離レベルについては以下のドキュメントで述べられている。</p>
<ul>
<li><a href=https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html>15.7.2.1 Transaction Isolation Levels</a></li>
</ul>
<p>MySQL (というか InnoDB?) では次の4つの分離レベルを設定することができる。</p>
<ul>
<li><code>READ UNCOMMITTED</code></li>
<li><code>READ COMMITTED</code></li>
<li><code>REPEATABLE READ</code> (default)</li>
<li><code>SERIALIZABLE</code></li>
</ul>
<p>デフォルトの分離レベルは <code>REPEATABLE READ</code> だが、これは前述の snapshot isolation に相当するらしい。<br>
分離レベルは、例えば <code>set transaction</code> 構文により次のようにして指定できる。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=color:#66d9ef>set</span> transaction isolation level SERIALIZABLE;
</code></pre></div><p>この場合は現在のセッション内で実行される次のトランザクションについて適用される。<br>
すべてのセッションやすべてのトランザクション等の指定もできる。<br>
詳しくは以下。</p>
<ul>
<li><a href=https://dev.mysql.com/doc/refman/8.0/en/set-transaction.html>13.3.7 SET TRANSACTION Statement</a></li>
</ul>
<h2 id=hive-の場合>Hive の場合<a hidden class=anchor aria-hidden=true href=#hive-の場合>#</a></h2>
<p>Hive についてはドキュメントに次のような記載がある。</p>
<blockquote>
<p>At this time only snapshot level isolation is supported. When a given query starts it will be provided with a consistent snapshot of the data.<br>
&ndash; <a href=https://cwiki.apache.org/confluence/display/Hive/Hive+Transactions#HiveTransactions-Limitations>Hive Transactions</a></p>
</blockquote>
<p>Hive は snapshot isolation のみ提供しているとのこと。</p>
<blockquote>
<p>The default DummyTxnManager emulates behavior of old Hive versions: has no transactions and uses hive.lock.manager property to create lock manager for tables, partitions and databases.<br>
&ndash; <a href=https://cwiki.apache.org/confluence/display/Hive/Hive+Transactions#HiveTransactions-Transaction/LockManager>Hive Transactions</a></p>
</blockquote>
<p>lock は小さくとも partition の単位になるのだろうか。<br>
であるとすると予想通りだが MySQL よりもいかつい挙動になっている。</p>
<p>このように多くの DB では snapshot isolation の分離レベルが基本となっている。</p>
<h1 id=spark-クエリの分離レベル>Spark クエリの分離レベル<a hidden class=anchor aria-hidden=true href=#spark-クエリの分離レベル>#</a></h1>
<p>では Spark のクエリはどうだろうか。<br>
ここからようやく本題となる。</p>
<h2 id=read-committed-相当>read committed 相当<a hidden class=anchor aria-hidden=true href=#read-committed-相当>#</a></h2>
<p>Spark において <code>DataFrame</code> を用いたデータ処理を記述するとき、それは1つの SQL クエリを書くのと近い感覚になる。<br>
そもそも <code>DataFrame</code> は SQL-like な使い心地を目的として作られた API だから当然だ。</p>
<p><code>DataFrame</code> で記述された処理は実行時に <code>RDD</code> として翻訳されるが、分離レベルを考えるにあたって <code>RDD</code> の特性がキーとなってくる。</p>
<blockquote>
<p>By default, each transformed RDD may be recomputed each time you run an action on it.<br>
&ndash; <a href=https://spark.apache.org/docs/3.0.0/rdd-programming-guide.html#rdd-operations>RDD Operations</a></p>
</blockquote>
<p>あまり良い説明を見つけられなかったが、1回の action を伴う処理においても同じ <code>RDD</code> が複数回参照されるとき、その <code>RDD</code> までの計算は通常やり直されることになる。</p>
<p>したがって例えば self join のようなことをするとき、同じデータソースを2回読みに行くということが起こってしまう。<br>
HDFS や S3 上のファイル、JDBC 経由の外部 DB など Spark は様々なデータソースを扱うことができるが、通常 Spark がその2回の読み込みに対して lock をかけたりすることはできない。</p>
<p>つまり non-repeatable read や phantom read を防ぐことができない。<br>
read committed という弱い分離レベルに相当するということになってしまう。</p>
<p>分離レベルという言葉はトランザクションという概念に対して使われるものであり、<code>DataFrame</code> のクエリをトランザクションと呼んでいいのかはわからない。<br>
なので分離レベルという言葉をここで使うのが適切でないかもしれないということは述べておく。</p>
<h2 id=検証>検証<a hidden class=anchor aria-hidden=true href=#検証>#</a></h2>
<p>MySQL からデータを読み取り Spark で処理することを考える。<br>
まず local の MySQL で次のような table を用意する。</p>
<pre tabindex=0><code>mysql&gt; describe employees;
+---------------+---------+------+-----+---------+-------+
| Field         | Type    | Null | Key | Default | Extra |
+---------------+---------+------+-----+---------+-------+
| id            | int(11) | NO   | PRI | NULL    |       |
| salary        | int(11) | YES  |     | NULL    |       |
| department_id | int(11) | YES  |     | NULL    |       |
+---------------+---------+------+-----+---------+-------+
3 rows in set (0.03 sec)
</code></pre><p>部署 (department) ごとの給料 (salary) の平均から各従業員の給料がどれくらい離れているかの差分を見たいものとする。<br>
Spark のコードは次のようになる。<br>
Spark のバージョンはこれを書いている時点での最新 3.0.0 とした。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>package</span> com.example

<span style=color:#66d9ef>import</span> org.apache.spark.sql.functions.avg
<span style=color:#66d9ef>import</span> org.apache.spark.sql.SparkSession

<span style=color:#66d9ef>object</span> <span style=color:#a6e22e>IsolationLevelExperiment</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>def</span> main<span style=color:#f92672>(</span>args<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Array</span><span style=color:#f92672>[</span><span style=color:#66d9ef>String</span><span style=color:#f92672>])</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Unit</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
    <span style=color:#75715e>// Prepare SparkSession
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>val</span> spark <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>SparkSession</span>
      <span style=color:#f92672>.</span>builder<span style=color:#f92672>()</span>
      <span style=color:#f92672>.</span>appName<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Isolation Level Experiment&#34;</span><span style=color:#f92672>)</span>
      <span style=color:#f92672>.</span>master<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;local[*]&#34;</span><span style=color:#f92672>)</span>
      <span style=color:#f92672>.</span>getOrCreate<span style=color:#f92672>()</span>

    <span style=color:#66d9ef>import</span> spark.implicits._

    <span style=color:#75715e>// Read from MySQL
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>val</span> dfEmployee <span style=color:#66d9ef>=</span> spark
      <span style=color:#f92672>.</span>read
      <span style=color:#f92672>.</span>format<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;jdbc&#34;</span><span style=color:#f92672>)</span>
      <span style=color:#f92672>.</span>option<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;url&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;jdbc:mysql://localhost&#34;</span><span style=color:#f92672>)</span>
      <span style=color:#f92672>.</span>option<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;dbtable&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;db_name.employees&#34;</span><span style=color:#f92672>)</span>
      <span style=color:#f92672>.</span>option<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;user&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;user_name&#34;</span><span style=color:#f92672>)</span>
      <span style=color:#f92672>.</span>option<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;password&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;********&#34;</span><span style=color:#f92672>)</span>
      <span style=color:#f92672>.</span>option<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;driver&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;com.mysql.cj.jdbc.Driver&#34;</span><span style=color:#f92672>)</span>
      <span style=color:#f92672>.</span>load
      <span style=color:#f92672>.</span>cache

    <span style=color:#75715e>// Get average salary
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>val</span> dfAvg <span style=color:#66d9ef>=</span> dfEmployee
      <span style=color:#f92672>.</span>groupBy<span style=color:#f92672>(</span>$<span style=color:#e6db74>&#34;department_id&#34;</span><span style=color:#f92672>)</span>
      <span style=color:#f92672>.</span>agg<span style=color:#f92672>(</span>avg<span style=color:#f92672>(</span>$<span style=color:#e6db74>&#34;salary&#34;</span><span style=color:#f92672>).</span>as<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;avg_salary&#34;</span><span style=color:#f92672>))</span>

    <span style=color:#75715e>// Calculate diff
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>val</span> dfResult <span style=color:#66d9ef>=</span> dfEmployee
      <span style=color:#f92672>.</span>as<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;e&#34;</span><span style=color:#f92672>)</span>
      <span style=color:#f92672>.</span>join<span style=color:#f92672>(</span>
        dfAvg<span style=color:#f92672>.</span>as<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;a&#34;</span><span style=color:#f92672>),</span>
        $<span style=color:#e6db74>&#34;e.department_id&#34;</span> <span style=color:#f92672>===</span> $<span style=color:#e6db74>&#34;a.department_id&#34;</span><span style=color:#f92672>,</span>
        <span style=color:#e6db74>&#34;left_outer&#34;</span>
      <span style=color:#f92672>)</span>
      <span style=color:#f92672>.</span>select<span style=color:#f92672>(</span>
        $<span style=color:#e6db74>&#34;e.id&#34;</span><span style=color:#f92672>,</span>
        $<span style=color:#e6db74>&#34;e.department_id&#34;</span><span style=color:#f92672>,</span>
        <span style=color:#f92672>(</span>$<span style=color:#e6db74>&#34;e.salary&#34;</span> <span style=color:#f92672>-</span> $<span style=color:#e6db74>&#34;a.avg_salary&#34;</span><span style=color:#f92672>).</span>as<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;salary_diff&#34;</span><span style=color:#f92672>)</span>
      <span style=color:#f92672>)</span>

    <span style=color:#75715e>// Output results
</span><span style=color:#75715e></span>    dfResult<span style=color:#f92672>.</span>show

    spark<span style=color:#f92672>.</span>stop<span style=color:#f92672>()</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>このコードを実行する前に MySQL の <a href=https://dev.mysql.com/doc/refman/8.0/en/query-log.html>general query log</a> を ON にする。</p>
<pre tabindex=0><code>mysql&gt; set global general_log = 'ON';
Query OK, 0 rows affected (0.02 sec)

mysql&gt; show global variables like 'general_log%';
+------------------+--------------------------------------+
| Variable_name    | Value                                |
+------------------+--------------------------------------+
| general_log      | ON                                   |
| general_log_file | /usr/local/var/mysql/MacBook-Pro.log |
+------------------+--------------------------------------+
2 rows in set (0.01 sec)
</code></pre><p>これによって MySQL に対して発行されたクエリがログとして記録されるようになる。</p>
<p>直感的に snapshot isolation になっているのであれば MySQL に対する select 文は1回だけ発行されるはずである。<br>
しかし前述のとおり <code>RDD</code> や <code>DataFrame</code> の処理は途中の状態を通常保存せず、同じ <code>RDD</code> や <code>DataFrame</code> を参照していたとしても再計算される。<br>
上記コードの例だと <code>dfEmployee</code> が2回参照されている。</p>
<p>コードを実行すると general query log には次のように、データ取得のための select 文が2つ記録されていた。<br>
それぞれ <code>join()</code> の左右の table のデータソースを示している。</p>
<pre tabindex=0><code>8 Query     SELECT `id`,`salary`,`department_id` FROM test_fout_dsp.employees
7 Query     SELECT `salary`,`department_id` FROM test_fout_dsp.employees WHERE (`department_id` IS NOT NULL)
</code></pre><p>2つの select 文はそれぞれ別のクエリ、トランザクションとして発行されている。<br>
したがって前者の select 文が実行された後、後者の select 文が実行される前に別のトランザクションにより <code>employees</code> が更新されたり挿入・削除されたりすると non-repeatable read や phantom read が発生してしまうのである。</p>
<p>今回はデータソースへのアクセスを確認するためにデータソースとして MySQL を使ったが、同じことはファイルや他の DB など別のデータソースで起こりうる。</p>
<h2 id=回避策>回避策<a hidden class=anchor aria-hidden=true href=#回避策>#</a></h2>
<p>プロダクト運用上、non-repeatable read や phantom read が発生しうる状況というのは多くの場合で厄介である。<br>
一時的なデータソースの状態に依存して問題が発生するため、バグの原因追求がとても困難だからだ。<br>
見た目上の分離レベルを強くし、これらを避けるには2つの方法が考えられる。</p>
<h3 id=immutable-なデータにのみアクセスする>immutable なデータにのみアクセスする<a hidden class=anchor aria-hidden=true href=#immutable-なデータにのみアクセスする>#</a></h3>
<p>単純な話で non-repeatable read や phantom read が発生するようなデータソースを参照しなければよい。<br>
例えばユーザの行動ログのような蓄積されていくデータが hour 単位で partitioning されているような場合、基本的に過去の partition に対しては変更や挿入・削除は行われない。<br>
このような partition にアクセスする分には前述のような厄介な問題は起こらない。</p>
<h3 id=cache-する>cache する<a hidden class=anchor aria-hidden=true href=#cache-する>#</a></h3>
<p>データソースから読み取った結果の <code>DataFrame</code> に対して <code>cache()</code> または <code>persist()</code> をするとよい。</p>
<blockquote>
<p>Spark SQL can cache tables using an in-memory columnar format by calling spark.catalog.cacheTable("tableName") or dataFrame.cache().<br>
&ndash; <a href=https://spark.apache.org/docs/latest/sql-performance-tuning.html#caching-data-in-memory>Caching Data In Memory</a></p>
</blockquote>
<p>前述のコードで <code>dfEmployee</code> に対して <code>.cache()</code> をした場合、MySQL へのデータ取得のための select 文の発行は1回になった。<br>
大きなデータソースを <code>cache()</code> するときだけメモリや HDD 容量に気をつけておきたい。</p>
<h1 id=まとめ>まとめ<a hidden class=anchor aria-hidden=true href=#まとめ>#</a></h1>
<p><code>DataFrame</code> はいわゆる RDBMS を操作しているように見えてしまうところが難しいところだろうか。<br>
「データ指向アプリケーションデザイン」に至極真っ当なことが書いてあったので、その言葉を借りて締めておく。</p>
<blockquote>
<p>何も考えずにツールを信じて依存するのではなく、並行性の問題にはどういったものがあるのか、そしてそれらを回避するにはどうしたら良いのかを、しっかり理解しなければなりません。そうすれば、信頼性があり、正しく動作するアプリケーションを手の届くツールを使って構築できるようになります。<br>
&ndash; Martin Kleppmann <a href=https://www.oreilly.co.jp/books/9784873118703/>データ指向アプリケーションデザイン</a></p>
</blockquote>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://soonraah.github.io/tags/apache-spark/>Apache Spark</a></li>
<li><a href=https://soonraah.github.io/tags/transaction/>transaction</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://soonraah.github.io/posts/spark-meetup-tokyo-3/>
<span class=title>« 前のページ</span>
<br>
<span>勉強会メモ: Spark Meetup Tokyo #3 Online</span>
</a>
<a class=next href=https://soonraah.github.io/posts/study-spark-3-0-0/>
<span class=title>次のページ »</span>
<br>
<span>Apache Spark 3.0.0 について調べた</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share Spark DataFrame クエリの弱い分離レベル on twitter" href="https://twitter.com/intent/tweet/?text=Spark%20DataFrame%20%e3%82%af%e3%82%a8%e3%83%aa%e3%81%ae%e5%bc%b1%e3%81%84%e5%88%86%e9%9b%a2%e3%83%ac%e3%83%99%e3%83%ab&url=https%3a%2f%2fsoonraah.github.io%2fposts%2fweak_isolation_level_of_dataframe%2f&hashtags=ApacheSpark%2ctransaction"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Spark DataFrame クエリの弱い分離レベル on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fsoonraah.github.io%2fposts%2fweak_isolation_level_of_dataframe%2f&title=Spark%20DataFrame%20%e3%82%af%e3%82%a8%e3%83%aa%e3%81%ae%e5%bc%b1%e3%81%84%e5%88%86%e9%9b%a2%e3%83%ac%e3%83%99%e3%83%ab&summary=Spark%20DataFrame%20%e3%82%af%e3%82%a8%e3%83%aa%e3%81%ae%e5%bc%b1%e3%81%84%e5%88%86%e9%9b%a2%e3%83%ac%e3%83%99%e3%83%ab&source=https%3a%2f%2fsoonraah.github.io%2fposts%2fweak_isolation_level_of_dataframe%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Spark DataFrame クエリの弱い分離レベル on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fsoonraah.github.io%2fposts%2fweak_isolation_level_of_dataframe%2f&title=Spark%20DataFrame%20%e3%82%af%e3%82%a8%e3%83%aa%e3%81%ae%e5%bc%b1%e3%81%84%e5%88%86%e9%9b%a2%e3%83%ac%e3%83%99%e3%83%ab"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Spark DataFrame クエリの弱い分離レベル on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsoonraah.github.io%2fposts%2fweak_isolation_level_of_dataframe%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Spark DataFrame クエリの弱い分離レベル on whatsapp" href="https://api.whatsapp.com/send?text=Spark%20DataFrame%20%e3%82%af%e3%82%a8%e3%83%aa%e3%81%ae%e5%bc%b1%e3%81%84%e5%88%86%e9%9b%a2%e3%83%ac%e3%83%99%e3%83%ab%20-%20https%3a%2f%2fsoonraah.github.io%2fposts%2fweak_isolation_level_of_dataframe%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Spark DataFrame クエリの弱い分離レベル on telegram" href="https://telegram.me/share/url?text=Spark%20DataFrame%20%e3%82%af%e3%82%a8%e3%83%aa%e3%81%ae%e5%bc%b1%e3%81%84%e5%88%86%e9%9b%a2%e3%83%ac%e3%83%99%e3%83%ab&url=https%3a%2f%2fsoonraah.github.io%2fposts%2fweak_isolation_level_of_dataframe%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://soonraah.github.io>Froglog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerHTML='copy';function d(){a.innerHTML='copied!',setTimeout(()=>{a.innerHTML='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>