<!doctype html><html lang=ja dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>ストリーム処理システムに求められる機能性、および Apache Flink におけるその対応 - Froglog</title><meta name=keywords content="Apache Flink,stream processing"><meta name=description content="はじめに このポストではストリーム処理の survay 論文の話題に対して Apache Flink における例を挙げて紹介する。
論文概要 Fragkoulis, M., Carbone, P., Kalavri, V., & Katsifodimos, A. (2020). A Survey on the Evolution of Stream Processing Systems.
2020年の論文。
過去30年ぐらいのストリーム処理のフレームワークを調査し、その発展を論じている。
ストリーム処理に特徴的に求められるいくつかの機能性 (functionality) についてその実現方法をいくつか挙げ、比較的古いフレームワークと最近のフレームワークでの対比を行っている。
このポストのスコープ このポストでは前述のストリーム処理システムに求められる機能性とそれがなぜ必要となるかについて簡単にまとめる。
論文ではそこからさらにその実現方法がいくつか挙げられるが、ここでは個人的に興味がある Apache Flink ではどのように対処しているかを見ていく。
ちなみに論文中では Apache Flink はモダンなフレームワークの1つとしてちょいちょい引き合いに出されている。
ここでは Flink v1.11 をターゲットとする。
以下では論文で挙げられている機能性に沿って記載していく。
Out-of-order Data Management Out-of-order ストリーム処理システムにやってくるデータの順序は外的・内的要因により期待される順序になっていないことがある。
外的要因としてよくあるのはネットワークの問題。
データソース (producer) からストリーム処理システムに届くまでのルーティング、負荷など諸々の条件により各レコードごとに転送時間は一定にはならない。
各 operator の処理などストリーム処理システムの内的な要因で順序が乱されることもある。
out-of-order は処理の遅延や正しくない結果の原因となることがある。
out-of-order を管理するためにストリーム処理システムは処理の進捗を検出する必要がある。
&ldquo;進捗&rdquo; とはある時間経過でレコードの処理がどれだけ進んだかというもので、レコードの順序を表す属性 A (ex. event time) により定量化される。"><meta name=author content="soonraah"><link rel=canonical href=https://soonraah.github.io/posts/functionality-of-streaming-system/><meta name=google-site-verification content="XYZabc"><link href=https://soonraah.github.io/assets/css/stylesheet.min.595f5ecef354f9eb94e43d831cd360dcf8b7727542e731c55a7875c9e94a9577.css integrity="sha256-WV9ezvNU+euU5D2DHNNg3Pi3cnVC5zHFWnh1yelKlXc=" rel="preload stylesheet" as=style><link rel=manifest href=https://soonraah.github.io/site.webmanifest><link rel=icon href=https://soonraah.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://soonraah.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://soonraah.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://soonraah.github.io/apple-touch-icon.png><link rel=mask-icon href=https://soonraah.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.78.1"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-73329599-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="ストリーム処理システムに求められる機能性、および Apache Flink におけるその対応"><meta property="og:description" content="はじめに このポストではストリーム処理の survay 論文の話題に対して Apache Flink における例を挙げて紹介する。
論文概要 Fragkoulis, M., Carbone, P., Kalavri, V., & Katsifodimos, A. (2020). A Survey on the Evolution of Stream Processing Systems.
2020年の論文。
過去30年ぐらいのストリーム処理のフレームワークを調査し、その発展を論じている。
ストリーム処理に特徴的に求められるいくつかの機能性 (functionality) についてその実現方法をいくつか挙げ、比較的古いフレームワークと最近のフレームワークでの対比を行っている。
このポストのスコープ このポストでは前述のストリーム処理システムに求められる機能性とそれがなぜ必要となるかについて簡単にまとめる。
論文ではそこからさらにその実現方法がいくつか挙げられるが、ここでは個人的に興味がある Apache Flink ではどのように対処しているかを見ていく。
ちなみに論文中では Apache Flink はモダンなフレームワークの1つとしてちょいちょい引き合いに出されている。
ここでは Flink v1.11 をターゲットとする。
以下では論文で挙げられている機能性に沿って記載していく。
Out-of-order Data Management Out-of-order ストリーム処理システムにやってくるデータの順序は外的・内的要因により期待される順序になっていないことがある。
外的要因としてよくあるのはネットワークの問題。
データソース (producer) からストリーム処理システムに届くまでのルーティング、負荷など諸々の条件により各レコードごとに転送時間は一定にはならない。
各 operator の処理などストリーム処理システムの内的な要因で順序が乱されることもある。
out-of-order は処理の遅延や正しくない結果の原因となることがある。
out-of-order を管理するためにストリーム処理システムは処理の進捗を検出する必要がある。
&ldquo;進捗&rdquo; とはある時間経過でレコードの処理がどれだけ進んだかというもので、レコードの順序を表す属性 A (ex. event time) により定量化される。"><meta property="og:type" content="article"><meta property="og:url" content="https://soonraah.github.io/posts/functionality-of-streaming-system/"><meta property="og:image" content="https://soonraah.github.io/image/photo/nathan-anderson-8X1-pcDF8l0-unsplash.jpg"><meta property="article:published_time" content="2020-11-07T16:00:00+09:00"><meta property="article:modified_time" content="2020-11-07T16:00:00+09:00"><meta property="og:site_name" content="Froglog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://soonraah.github.io/image/photo/nathan-anderson-8X1-pcDF8l0-unsplash.jpg"><meta name=twitter:title content="ストリーム処理システムに求められる機能性、および Apache Flink におけるその対応"><meta name=twitter:description content="はじめに このポストではストリーム処理の survay 論文の話題に対して Apache Flink における例を挙げて紹介する。
論文概要 Fragkoulis, M., Carbone, P., Kalavri, V., & Katsifodimos, A. (2020). A Survey on the Evolution of Stream Processing Systems.
2020年の論文。
過去30年ぐらいのストリーム処理のフレームワークを調査し、その発展を論じている。
ストリーム処理に特徴的に求められるいくつかの機能性 (functionality) についてその実現方法をいくつか挙げ、比較的古いフレームワークと最近のフレームワークでの対比を行っている。
このポストのスコープ このポストでは前述のストリーム処理システムに求められる機能性とそれがなぜ必要となるかについて簡単にまとめる。
論文ではそこからさらにその実現方法がいくつか挙げられるが、ここでは個人的に興味がある Apache Flink ではどのように対処しているかを見ていく。
ちなみに論文中では Apache Flink はモダンなフレームワークの1つとしてちょいちょい引き合いに出されている。
ここでは Flink v1.11 をターゲットとする。
以下では論文で挙げられている機能性に沿って記載していく。
Out-of-order Data Management Out-of-order ストリーム処理システムにやってくるデータの順序は外的・内的要因により期待される順序になっていないことがある。
外的要因としてよくあるのはネットワークの問題。
データソース (producer) からストリーム処理システムに届くまでのルーティング、負荷など諸々の条件により各レコードごとに転送時間は一定にはならない。
各 operator の処理などストリーム処理システムの内的な要因で順序が乱されることもある。
out-of-order は処理の遅延や正しくない結果の原因となることがある。
out-of-order を管理するためにストリーム処理システムは処理の進捗を検出する必要がある。
&ldquo;進捗&rdquo; とはある時間経過でレコードの処理がどれだけ進んだかというもので、レコードの順序を表す属性 A (ex. event time) により定量化される。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ストリーム処理システムに求められる機能性、および Apache Flink におけるその対応","name":"ストリーム処理システムに求められる機能性、および Apache Flink におけるその対応","description":"はじめに このポストではストリーム処理の survay 論文の話題に対して Apache Flink における例を挙げて紹介する。\n論文概要 Fragkoulis, M., Carbone, P., Kalavri, V., \u0026amp;amp; Katsifodimos, A. (2020). A Survey on the Evolution of Stream …","keywords":["Apache Flink","stream processing"],"articleBody":"はじめに このポストではストリーム処理の survay 論文の話題に対して Apache Flink における例を挙げて紹介する。\n論文概要 Fragkoulis, M., Carbone, P., Kalavri, V., \u0026 Katsifodimos, A. (2020). A Survey on the Evolution of Stream Processing Systems.\n2020年の論文。\n過去30年ぐらいのストリーム処理のフレームワークを調査し、その発展を論じている。\nストリーム処理に特徴的に求められるいくつかの機能性 (functionality) についてその実現方法をいくつか挙げ、比較的古いフレームワークと最近のフレームワークでの対比を行っている。\nこのポストのスコープ このポストでは前述のストリーム処理システムに求められる機能性とそれがなぜ必要となるかについて簡単にまとめる。\n論文ではそこからさらにその実現方法がいくつか挙げられるが、ここでは個人的に興味がある Apache Flink ではどのように対処しているかを見ていく。\nちなみに論文中では Apache Flink はモダンなフレームワークの1つとしてちょいちょい引き合いに出されている。\nここでは Flink v1.11 をターゲットとする。\n以下では論文で挙げられている機能性に沿って記載していく。\nOut-of-order Data Management Out-of-order ストリーム処理システムにやってくるデータの順序は外的・内的要因により期待される順序になっていないことがある。\n外的要因としてよくあるのはネットワークの問題。\nデータソース (producer) からストリーム処理システムに届くまでのルーティング、負荷など諸々の条件により各レコードごとに転送時間は一定にはならない。\n各 operator の処理などストリーム処理システムの内的な要因で順序が乱されることもある。\nout-of-order は処理の遅延や正しくない結果の原因となることがある。\nout-of-order を管理するためにストリーム処理システムは処理の進捗を検出する必要がある。\n“進捗” とはある時間経過でレコードの処理がどれだけ進んだかというもので、レコードの順序を表す属性 A (ex. event time) により定量化される。\nある期間で処理された最古の A を進捗の尺度とみなすことができる。\nApache Flink の場合 Flink ではこの進捗を測るのに watermark という概念が使われている。\n Event Time and Watermarks    Apache Flink Event Time and Watermarks\n  (図が見にくい場合はページ上部の太陽みたいなマークをクリックして light mode にしてください)\nこちらの図でストリーム中の破線で描かれているのが watermark であり、W(11) の wartermark は「timestamp が11以下の event はこの後もう来ないものとみなす」ということを下流の operator に伝えるものである。\nwatermark は metadata 的なものだが、通常の event と同じようにストリーム中を流れている (これを panctuation という)。\n下流の operator が window 処理をしていた場合、W(11) が届いた時点で timestamp が11までのところの window 処理を完結してさらに下流に output することができる。\nwatermark がいつ・どのような値で発生するかについては Flink application の開発者の実装次第ということになる。\nしかし現実的には Writing a Periodic WatermarkGenerator の例にある BoundedOutOfOrdernessGenerator のように、 WatermarkGenerator にやってきた event の event time を元に決めることが多いと思われる。\nState Management ストリーム処理における状態 “状態” とは継続的なストリーム処理の中で内部的な副作用をとらえたもの。\nアクティブな window、レコードのかたまり、aggregation の進捗など。\nユーザ定義のものも含まれる。\n状態については以下のようなトピックがある。\n Programmability  プログラミングモデルにおいて状態がどのように定義・管理されるか 定義と管理についてそれぞれシステムとユーザの場合がある   Scalability and Persistency  最近のストリーム処理は scalable の時流を汲んでおり、scale out するときに状態をどのように扱うか 内外の記憶装置に状態を永続化するという方法がよく取られる   Consistency  transaction level の保証について    Apache Flink の場合 ドキュメントの TOP ページ における Flink を表す一文\n Apache Flink is a framework and distributed processing engine for stateful computations over unbounded and bounded data streams.\n においても “stateful” という言葉が使われているとおり、状態の扱いは Flink の設計思想の中でもかなり重要な部分となっている。\nFlink における状態の扱いについてはこちらを参照。\n Stateful Stream Processing  Programmability Flink では application 開発者が任意の状態を定義することができる。\n Working with State  一方で状態の管理はフレームワーク側でやってくれるので、開発者は checkpoint や restore 等のことは特に配慮する必要はない。\n論文中ではこれを “User-Declared System-Managed State” と呼んでおり、最近のストリーム処理システムの傾向となっている。\nScalability Flink では keyBy() により key-level の状態を持つことができる。\nkey ごとに並列 task 内での partitioning し、分散することが可能ということである。\nPersistency 論文では永続化については scalability と絡めて述べられていたが、Flink のドキュメントでは fault tolerance の文脈で永続化について書かれている。\nFlink の fault tolerance の肝は stream replay と checkpointing である。\ncheckpointing とはストリームと operator の状態の一貫性のあるスナップショットをとることである。\n Apache Flink Snapshotting Operator State\n  この checkpoint を作成する過程で各 operator の状態が state backend へと永続化される。\nstate backend では RocksDB の key/value store に各 checkpoint, 各 operator の状態が保存される。\n(RocksDB 以外にもメモリやファイルシステムなどもある)\nConsistency Flink では checkpoint のインターバルの期間の単位 (epoch という) で一貫性のある状態を永続化する。\n上図の barriers がその単位を決めている。\nChandy Lamport algorithm という分散スナップショットの手法がインスパイアされており、unaligned/aligned で各 operator の状態のスナップショットを取るようになっている。\nFault Tolerance \u0026 High Availability Fault Tolerance ストリーム処理システムにとって fault tolerance は2つの理由から重要である。\n ストリーム処理システムは stateful な計算を終わりのないデータに対して行っている  fault tolerance がなければ、障害があったときに最初から状態を計算しなおさなければならない 一方で、多くの場合過去に処理されたデータは既に失われている   最近のストリーム処理システムは分散アーキテクチャを採用している  物理マシンの数だけ問題が起こりやすくなる    output commit problem についても考慮する必要がある。\nこれは出力が公開された位置から状態を復元できることが確かな場合のみ、システムは外界に出力を公開するというもの。\n言い換えると、障害からの復旧時などに同じ出力を2回してしまわない、出力を exactly-once にできるかというものである。\nHigh Availability 過去の研究においてストリーム処理システムの可用性は recovery time, performance overhead (throughput \u0026 latency), resource utilization により定量化されてきた。\nこの論文では\n A streaming system is available when it can provide output based on the processing of its current input.\n を可用性の定義として提案する。\n時間ごとの processing time と event time の差により定量化される。\nApache Flink の場合 Fault Tolerance 論文中では Flink は output commit problem については Kafka などの出力先の外部システムの責任とするスタンスだとしている。\nKafka には idempotent producer という機能があり、たぶんこれのことを言っている。\nまた一方で TwoPhaseCommitSinkFunction の2相コミットによって exectly-once semantics を提供するという方法も示されている。\n An Overview of End-to-End Exactly-Once Processing in Apache Flink (with Apache Kafka, too!)  checkpointing における JobManager を2相コミットの coordinator とみなし、checkpoint barrier が最後の operator に到達するまでをコミット要求相、その後の JobManager からの checkpointing 完了通知をコミット相としている。\nコミット相において外部システムへの書き出しの transaction が完了する形となる。\nfault tolerance については State Management の項も参照。\nHigh Availability Flink のプロセスには JobManager と TaskManager があり、前者は cluster に1つだけ動く。\nしたがって JobManager が SPOF になり、可用性に影響しうる。\nhigh availability (高可用性) を実現するためには JobManager が SPOF となることを避けることができる。\nstandalone または YARN の cluster として deploy した場合は JobManager が SPOF となることを避けることができる。\n以下は standalone の例。\n1つの JobManager が leader として動いているが、それが crash すると standby のインスタンスが leader を引き継ぐ。\n(論文中では passive replication として紹介)\n Apache Flink Standalone Cluster High Availability\n  Load Management, Elasticity \u0026 Reconfiguration Load Management ストリーム処理システムは、外部のデータソースがデータを送る流速を制御することができない。\n入力データの流速がシステムのキャパより大きいことによるパフォーマンス劣化を防ぐための対応が必要となる。\n次のような手法がある。\n load shedding  多すぎる入力データを落とす方法   back-pressure  入力データを落とせないときに buffering と組み合わせて使う dataflow graph 上に速度制限が波及していく   elasticity  分散アーキテクチャと cloud にもとづく方法 いわゆる scale out    Apache Flink の場合 Flink では back pressure および elasticity の組み合わせとなっている。\nback pressure は一時的な入力データの増加に対応する。\n各 operator (subtask?) は入出力の buffer を持っており、これにより operator 間の処理速度の違いをある程度吸収できる。\nしかし入力データが著しく多くなると\n ボトルネックとなる operator の処理が滞る その operator の入力 buffer がいっぱいになる (ボトルネックではない) 上流の operator の出力 buffer がいっぱいになる 上流の operator の処理が滞る (以降繰り返し)  のように、dataflow graph の上流へ上流へと遅延が波及する。\nelasticity の面では、JobManager や TaskManager の追加や削除ができるようになっている。\n Adding JobManager/TaskManager Instances to a Cluster  TaskManager の追加や削除においては状態の再配分が行われる。\n再配分される状態は key group という単位で partitioning されており、consistent hash 的な方法で各 TaskManager 配下の operator へと配分される。\nちなみに AWS が提供する Flink の managed service である Amazon Kinesis Data Analytics for Apache Flink では CPU 使用率をモニタリングして自動的に scale out が行われるようになっている。\n Application Scaling in Kinesis Data Analytics for Apache Flink  まとめ バッチ処理ではあまりクリティカルにならないような問題でもストリーム処理では重大な影響を及ぼすことがある。\nストリーム処理に求められる機能性を実現するに当たり、Apache Flink では checkpoint の仕組みが中心的な役割を果たしているということが理解できた。\n","wordCount":"627","inLanguage":"ja","image":"https://soonraah.github.io/image/photo/nathan-anderson-8X1-pcDF8l0-unsplash.jpg","datePublished":"2020-11-07T16:00:00+09:00","dateModified":"2020-11-07T16:00:00+09:00","author":{"@type":"Person","name":"soonraah"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://soonraah.github.io/posts/functionality-of-streaming-system/"},"publisher":{"@type":"Organization","name":"Froglog","logo":{"@type":"ImageObject","url":"https://soonraah.github.io/favicon.ico"}}}</script></head><body class="single dark" id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else{document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://soonraah.github.io accesskey=h><img src=/image/brand/favicon.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><span class=theme-toggle><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://soonraah.github.io/about/><span>About</span></a></li><li><a href=https://soonraah.github.io/archives/><span>Archives</span></a></li><li><a href=https://soonraah.github.io/tags/><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>ストリーム処理システムに求められる機能性、および Apache Flink におけるその対応</h1><div class=post-meta>November 7, 2020&nbsp;·&nbsp;soonraah</div></header><figure class=entry-cover><img src=https://soonraah.github.io/image/photo/nathan-anderson-8X1-pcDF8l0-unsplash.jpg alt=Stream><p><a href=https://unsplash.com/photos/8X1-pcDF8l0>Photo by Nathan Anderson on Unsplash</a></p></figure><div class=toc><details><summary><div class=details accesskey=c>Table of Contents</div></summary><blockquote><ul><li><a href=#%e3%81%af%e3%81%98%e3%82%81%e3%81%ab aria-label=はじめに>はじめに</a><ul><li><a href=#%e8%ab%96%e6%96%87%e6%a6%82%e8%a6%81 aria-label=論文概要>論文概要</a></li><li><a href=#%e3%81%93%e3%81%ae%e3%83%9d%e3%82%b9%e3%83%88%e3%81%ae%e3%82%b9%e3%82%b3%e3%83%bc%e3%83%97 aria-label=このポストのスコープ>このポストのスコープ</a></li></ul></li><li><a href=#out-of-order-data-management aria-label="Out-of-order Data Management">Out-of-order Data Management</a><ul><li><a href=#out-of-order aria-label=Out-of-order>Out-of-order</a></li><li><a href=#apache-flink-%e3%81%ae%e5%a0%b4%e5%90%88 aria-label="Apache Flink の場合">Apache Flink の場合</a></li></ul></li><li><a href=#state-management aria-label="State Management">State Management</a><ul><li><a href=#%e3%82%b9%e3%83%88%e3%83%aa%e3%83%bc%e3%83%a0%e5%87%a6%e7%90%86%e3%81%ab%e3%81%8a%e3%81%91%e3%82%8b%e7%8a%b6%e6%85%8b aria-label=ストリーム処理における状態>ストリーム処理における状態</a></li><li><a href=#apache-flink-%e3%81%ae%e5%a0%b4%e5%90%88-1 aria-label="Apache Flink の場合">Apache Flink の場合</a><ul><li><a href=#programmability aria-label=Programmability>Programmability</a></li><li><a href=#scalability aria-label=Scalability>Scalability</a></li><li><a href=#persistency aria-label=Persistency>Persistency</a></li><li><a href=#consistency aria-label=Consistency>Consistency</a></li></ul></li></ul></li><li><a href=#fault-tolerance--high-availability aria-label="Fault Tolerance &amp;amp; High Availability">Fault Tolerance & High Availability</a><ul><li><a href=#fault-tolerance aria-label="Fault Tolerance">Fault Tolerance</a></li><li><a href=#high-availability aria-label="High Availability">High Availability</a></li><li><a href=#apache-flink-%e3%81%ae%e5%a0%b4%e5%90%88-2 aria-label="Apache Flink の場合">Apache Flink の場合</a><ul><li><a href=#fault-tolerance-1 aria-label="Fault Tolerance">Fault Tolerance</a></li><li><a href=#high-availability-1 aria-label="High Availability">High Availability</a></li></ul></li></ul></li><li><a href=#load-management-elasticity--reconfiguration aria-label="Load Management, Elasticity &amp;amp; Reconfiguration">Load Management, Elasticity & Reconfiguration</a><ul><li><a href=#load-management aria-label="Load Management">Load Management</a></li><li><a href=#apache-flink-%e3%81%ae%e5%a0%b4%e5%90%88-3 aria-label="Apache Flink の場合">Apache Flink の場合</a></li></ul></li><li><a href=#%e3%81%be%e3%81%a8%e3%82%81 aria-label=まとめ>まとめ</a></li></ul></blockquote></details></div><div class=post-content><h2 id=はじめに>はじめに</h2><p>このポストではストリーム処理の survay 論文の話題に対して Apache Flink における例を挙げて紹介する。</p><h3 id=論文概要>論文概要</h3><p><a href=https://arxiv.org/abs/2008.00842>Fragkoulis, M., Carbone, P., Kalavri, V., & Katsifodimos, A. (2020). A Survey on the Evolution of Stream Processing Systems.</a></p><p>2020年の論文。<br>過去30年ぐらいのストリーム処理のフレームワークを調査し、その発展を論じている。<br>ストリーム処理に特徴的に求められるいくつかの機能性 (functionality) についてその実現方法をいくつか挙げ、比較的古いフレームワークと最近のフレームワークでの対比を行っている。</p><h3 id=このポストのスコープ>このポストのスコープ</h3><p>このポストでは前述のストリーム処理システムに求められる機能性とそれがなぜ必要となるかについて簡単にまとめる。<br>論文ではそこからさらにその実現方法がいくつか挙げられるが、ここでは個人的に興味がある Apache Flink ではどのように対処しているかを見ていく。<br>ちなみに論文中では Apache Flink はモダンなフレームワークの1つとしてちょいちょい引き合いに出されている。<br>ここでは Flink v1.11 をターゲットとする。</p><p>以下では論文で挙げられている機能性に沿って記載していく。</p><h2 id=out-of-order-data-management>Out-of-order Data Management</h2><h3 id=out-of-order>Out-of-order</h3><p>ストリーム処理システムにやってくるデータの順序は外的・内的要因により期待される順序になっていないことがある。<br>外的要因としてよくあるのはネットワークの問題。<br>データソース (producer) からストリーム処理システムに届くまでのルーティング、負荷など諸々の条件により各レコードごとに転送時間は一定にはならない。<br>各 operator の処理などストリーム処理システムの内的な要因で順序が乱されることもある。<br>out-of-order は処理の遅延や正しくない結果の原因となることがある。</p><p>out-of-order を管理するためにストリーム処理システムは処理の進捗を検出する必要がある。<br>&ldquo;進捗&rdquo; とはある時間経過でレコードの処理がどれだけ進んだかというもので、レコードの順序を表す属性 <em>A</em> (ex. event time) により定量化される。<br>ある期間で処理された最古の <em>A</em> を進捗の尺度とみなすことができる。</p><h3 id=apache-flink-の場合>Apache Flink の場合</h3><p>Flink ではこの進捗を測るのに <strong>watermark</strong> という概念が使われている。</p><ul><li><a href=https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/timely-stream-processing.html#event-time-and-watermarks>Event Time and Watermarks</a></li></ul><figure><img src=/image/flink/stream_watermark_out_of_order.svg alt="Apache Flink"><figcaption><p>Apache Flink
<a href=https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/timely-stream-processing.html#event-time-and-watermarks>Event Time and Watermarks</a></p></figcaption></figure><p>(図が見にくい場合はページ上部の太陽みたいなマークをクリックして light mode にしてください)</p><p>こちらの図でストリーム中の破線で描かれているのが watermark であり、<em>W(11)</em> の wartermark は「timestamp が11以下の event はこの後もう来ないものとみなす」ということを下流の operator に伝えるものである。<br>watermark は metadata 的なものだが、通常の event と同じようにストリーム中を流れている (これを panctuation という)。<br>下流の operator が window 処理をしていた場合、<em>W(11)</em> が届いた時点で timestamp が11までのところの window 処理を完結してさらに下流に output することができる。</p><p>watermark がいつ・どのような値で発生するかについては Flink application の開発者の実装次第ということになる。<br>しかし現実的には <a href=https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/event_timestamps_watermarks.html#writing-a-periodic-watermarkgenerator>Writing a Periodic WatermarkGenerator</a> の例にある <code>BoundedOutOfOrdernessGenerator</code> のように、 <code>WatermarkGenerator</code> にやってきた event の event time を元に決めることが多いと思われる。</p><h2 id=state-management>State Management</h2><h3 id=ストリーム処理における状態>ストリーム処理における状態</h3><p>&ldquo;状態&rdquo; とは継続的なストリーム処理の中で内部的な副作用をとらえたもの。<br>アクティブな window、レコードのかたまり、aggregation の進捗など。<br>ユーザ定義のものも含まれる。<br>状態については以下のようなトピックがある。</p><ul><li>Programmability<ul><li>プログラミングモデルにおいて状態がどのように定義・管理されるか</li><li>定義と管理についてそれぞれシステムとユーザの場合がある</li></ul></li><li>Scalability and Persistency<ul><li>最近のストリーム処理は scalable の時流を汲んでおり、scale out するときに状態をどのように扱うか</li><li>内外の記憶装置に状態を永続化するという方法がよく取られる</li></ul></li><li>Consistency<ul><li>transaction level の保証について</li></ul></li></ul><h3 id=apache-flink-の場合-1>Apache Flink の場合</h3><p>ドキュメントの <a href=https://ci.apache.org/projects/flink/flink-docs-release-1.11/>TOP ページ</a> における Flink を表す一文</p><blockquote><p>Apache Flink is a framework and distributed processing engine for stateful computations over unbounded and bounded data streams.</p></blockquote><p>においても &ldquo;stateful&rdquo; という言葉が使われているとおり、状態の扱いは Flink の設計思想の中でもかなり重要な部分となっている。<br>Flink における状態の扱いについてはこちらを参照。</p><ul><li><a href=https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/stateful-stream-processing.html>Stateful Stream Processing</a></li></ul><h4 id=programmability>Programmability</h4><p>Flink では application 開発者が任意の状態を定義することができる。</p><ul><li><a href=https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/state.html>Working with State</a></li></ul><p>一方で状態の管理はフレームワーク側でやってくれるので、開発者は checkpoint や restore 等のことは特に配慮する必要はない。<br>論文中ではこれを &ldquo;User-Declared System-Managed State&rdquo; と呼んでおり、最近のストリーム処理システムの傾向となっている。</p><h4 id=scalability>Scalability</h4><p>Flink では <code>keyBy()</code> により key-level の状態を持つことができる。<br>key ごとに並列 task 内での partitioning し、分散することが可能ということである。</p><h4 id=persistency>Persistency</h4><p>論文では永続化については scalability と絡めて述べられていたが、<a href=https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/stateful-stream-processing.html#state-persistence>Flink のドキュメント</a>では fault tolerance の文脈で永続化について書かれている。</p><p>Flink の fault tolerance の肝は stream replay と checkpointing である。<br>checkpointing とはストリームと operator の状態の一貫性のあるスナップショットをとることである。</p><figure class=center><img src=/image/flink/checkpointing.svg alt="Apache Flink"><figcaption><p>Apache Flink
<a href=https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/stateful-stream-processing.html#snapshotting-operator-state>Snapshotting Operator State</a></p></figcaption></figure><p>この checkpoint を作成する過程で各 operator の状態が state backend へと永続化される。<br>state backend では <a href=https://rocksdb.org/>RocksDB</a> の key/value store に各 checkpoint, 各 operator の状態が保存される。<br>(RocksDB 以外にもメモリやファイルシステムなどもある)</p><h4 id=consistency>Consistency</h4><p>Flink では checkpoint のインターバルの期間の単位 (epoch という) で一貫性のある状態を永続化する。<br>上図の barriers がその単位を決めている。<br>Chandy Lamport algorithm という分散スナップショットの手法がインスパイアされており、unaligned/aligned で各 operator の状態のスナップショットを取るようになっている。</p><h2 id=fault-tolerance--high-availability>Fault Tolerance & High Availability</h2><h3 id=fault-tolerance>Fault Tolerance</h3><p>ストリーム処理システムにとって fault tolerance は2つの理由から重要である。</p><ul><li>ストリーム処理システムは stateful な計算を終わりのないデータに対して行っている<ul><li>fault tolerance がなければ、障害があったときに最初から状態を計算しなおさなければならない</li><li>一方で、多くの場合過去に処理されたデータは既に失われている</li></ul></li><li>最近のストリーム処理システムは分散アーキテクチャを採用している<ul><li>物理マシンの数だけ問題が起こりやすくなる</li></ul></li></ul><p>output commit problem についても考慮する必要がある。<br>これは出力が公開された位置から状態を復元できることが確かな場合のみ、システムは外界に出力を公開するというもの。<br>言い換えると、障害からの復旧時などに同じ出力を2回してしまわない、出力を <em>exactly-once</em> にできるかというものである。</p><h3 id=high-availability>High Availability</h3><p>過去の研究においてストリーム処理システムの可用性は recovery time, performance overhead (throughput & latency), resource utilization により定量化されてきた。<br>この論文では</p><blockquote><p><em>A streaming system is available when it can provide output based on the processing of its current input.</em></p></blockquote><p>を可用性の定義として提案する。<br>時間ごとの processing time と event time の差により定量化される。</p><h3 id=apache-flink-の場合-2>Apache Flink の場合</h3><h4 id=fault-tolerance-1>Fault Tolerance</h4><p>論文中では Flink は output commit problem については Kafka などの出力先の外部システムの責任とするスタンスだとしている。<br>Kafka には <a href=https://cwiki.apache.org/confluence/display/KAFKA/Idempotent+Producer>idempotent producer</a> という機能があり、たぶんこれのことを言っている。</p><p>また一方で <code>TwoPhaseCommitSinkFunction</code> の2相コミットによって <em>exectly-once</em> semantics を提供するという方法も示されている。</p><ul><li><a href=https://flink.apache.org/features/2018/03/01/end-to-end-exactly-once-apache-flink.html>An Overview of End-to-End Exactly-Once Processing in Apache Flink (with Apache Kafka, too!)</a></li></ul><p>checkpointing における JobManager を2相コミットの coordinator とみなし、checkpoint barrier が最後の operator に到達するまでをコミット要求相、その後の JobManager からの checkpointing 完了通知をコミット相としている。<br>コミット相において外部システムへの書き出しの transaction が完了する形となる。</p><p>fault tolerance については State Management の項も参照。</p><h4 id=high-availability-1>High Availability</h4><p>Flink のプロセスには <a href=https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/flink-architecture.html#anatomy-of-a-flink-cluster>JobManager と TaskManager</a> があり、前者は cluster に1つだけ動く。<br>したがって JobManager が SPOF になり、可用性に影響しうる。</p><p>high availability (高可用性) を実現するためには JobManager が SPOF となることを避けることができる。<br>standalone または YARN の cluster として deploy した場合は JobManager が SPOF となることを避けることができる。</p><p>以下は standalone の例。<br>1つの JobManager が leader として動いているが、それが crash すると standby のインスタンスが leader を引き継ぐ。<br>(論文中では passive replication として紹介)</p><figure class=center><img src=/image/flink/jobmanager_ha_overview.png alt="Apache Flink"><figcaption><p>Apache Flink
<a href=https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/jobmanager_high_availability.html#standalone-cluster-high-availability>Standalone Cluster High Availability</a></p></figcaption></figure><h2 id=load-management-elasticity--reconfiguration>Load Management, Elasticity & Reconfiguration</h2><h3 id=load-management>Load Management</h3><p>ストリーム処理システムは、外部のデータソースがデータを送る流速を制御することができない。<br>入力データの流速がシステムのキャパより大きいことによるパフォーマンス劣化を防ぐための対応が必要となる。<br>次のような手法がある。</p><ul><li>load shedding<ul><li>多すぎる入力データを落とす方法</li></ul></li><li>back-pressure<ul><li>入力データを落とせないときに buffering と組み合わせて使う</li><li>dataflow graph 上に速度制限が波及していく</li></ul></li><li>elasticity<ul><li>分散アーキテクチャと cloud にもとづく方法</li><li>いわゆる scale out</li></ul></li></ul><h3 id=apache-flink-の場合-3>Apache Flink の場合</h3><p>Flink では <a href=https://ci.apache.org/projects/flink/flink-docs-release-1.11/monitoring/back_pressure.html#back-pressure>back pressure</a> および elasticity の組み合わせとなっている。</p><p>back pressure は一時的な入力データの増加に対応する。<br>各 operator (subtask?) は入出力の buffer を持っており、これにより operator 間の処理速度の違いをある程度吸収できる。<br>しかし入力データが著しく多くなると</p><ol><li>ボトルネックとなる operator の処理が滞る</li><li>その operator の入力 buffer がいっぱいになる</li><li>(ボトルネックではない) 上流の operator の出力 buffer がいっぱいになる</li><li>上流の operator の処理が滞る</li><li>(以降繰り返し)</li></ol><p>のように、dataflow graph の上流へ上流へと遅延が波及する。</p><p>elasticity の面では、JobManager や TaskManager の追加や削除ができるようになっている。</p><ul><li><a href=https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/deployment/cluster_setup.html#adding-jobmanagertaskmanager-instances-to-a-cluster>Adding JobManager/TaskManager Instances to a Cluster</a></li></ul><p>TaskManager の追加や削除においては状態の再配分が行われる。<br>再配分される状態は key group という単位で partitioning されており、consistent hash 的な方法で各 TaskManager 配下の operator へと配分される。</p><p>ちなみに AWS が提供する Flink の managed service である Amazon Kinesis Data Analytics for Apache Flink では CPU 使用率をモニタリングして自動的に scale out が行われるようになっている。</p><ul><li><a href=https://docs.aws.amazon.com/kinesisanalytics/latest/java/how-scaling.html>Application Scaling in Kinesis Data Analytics for Apache Flink</a></li></ul><h2 id=まとめ>まとめ</h2><p>バッチ処理ではあまりクリティカルにならないような問題でもストリーム処理では重大な影響を及ぼすことがある。<br>ストリーム処理に求められる機能性を実現するに当たり、Apache Flink では checkpoint の仕組みが中心的な役割を果たしているということが理解できた。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://soonraah.github.io/tags/apache-flink>Apache Flink</a></li><li><a href=https://soonraah.github.io/tags/stream-processing>stream processing</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share ストリーム処理システムに求められる機能性、および Apache Flink におけるその対応 on twitter" href="https://twitter.com/intent/tweet/?text=%e3%82%b9%e3%83%88%e3%83%aa%e3%83%bc%e3%83%a0%e5%87%a6%e7%90%86%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0%e3%81%ab%e6%b1%82%e3%82%81%e3%82%89%e3%82%8c%e3%82%8b%e6%a9%9f%e8%83%bd%e6%80%a7%e3%80%81%e3%81%8a%e3%82%88%e3%81%b3%20Apache%20Flink%20%e3%81%ab%e3%81%8a%e3%81%91%e3%82%8b%e3%81%9d%e3%81%ae%e5%af%be%e5%bf%9c&url=https%3a%2f%2fsoonraah.github.io%2fposts%2ffunctionality-of-streaming-system%2f&hashtags=ApacheFlink%2cstreamprocessing"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-253.927 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ストリーム処理システムに求められる機能性、および Apache Flink におけるその対応 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fsoonraah.github.io%2fposts%2ffunctionality-of-streaming-system%2f&title=%e3%82%b9%e3%83%88%e3%83%aa%e3%83%bc%e3%83%a0%e5%87%a6%e7%90%86%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0%e3%81%ab%e6%b1%82%e3%82%81%e3%82%89%e3%82%8c%e3%82%8b%e6%a9%9f%e8%83%bd%e6%80%a7%e3%80%81%e3%81%8a%e3%82%88%e3%81%b3%20Apache%20Flink%20%e3%81%ab%e3%81%8a%e3%81%91%e3%82%8b%e3%81%9d%e3%81%ae%e5%af%be%e5%bf%9c&summary=%e3%82%b9%e3%83%88%e3%83%aa%e3%83%bc%e3%83%a0%e5%87%a6%e7%90%86%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0%e3%81%ab%e6%b1%82%e3%82%81%e3%82%89%e3%82%8c%e3%82%8b%e6%a9%9f%e8%83%bd%e6%80%a7%e3%80%81%e3%81%8a%e3%82%88%e3%81%b3%20Apache%20Flink%20%e3%81%ab%e3%81%8a%e3%81%91%e3%82%8b%e3%81%9d%e3%81%ae%e5%af%be%e5%bf%9c&source=https%3a%2f%2fsoonraah.github.io%2fposts%2ffunctionality-of-streaming-system%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0v-129.439c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02v-126.056c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768h75.024zm-307.552-334.556c-25.674.0-42.448 16.879-42.448 39.002.0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ストリーム処理システムに求められる機能性、および Apache Flink におけるその対応 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fsoonraah.github.io%2fposts%2ffunctionality-of-streaming-system%2f&title=%e3%82%b9%e3%83%88%e3%83%aa%e3%83%bc%e3%83%a0%e5%87%a6%e7%90%86%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0%e3%81%ab%e6%b1%82%e3%82%81%e3%82%89%e3%82%8c%e3%82%8b%e6%a9%9f%e8%83%bd%e6%80%a7%e3%80%81%e3%81%8a%e3%82%88%e3%81%b3%20Apache%20Flink%20%e3%81%ab%e3%81%8a%e3%81%91%e3%82%8b%e3%81%9d%e3%81%ae%e5%af%be%e5%bf%9c"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zm-119.474 108.193c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zm-160.386-29.702c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ストリーム処理システムに求められる機能性、および Apache Flink におけるその対応 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsoonraah.github.io%2fposts%2ffunctionality-of-streaming-system%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978v-192.915h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ストリーム処理システムに求められる機能性、および Apache Flink におけるその対応 on whatsapp" href="https://api.whatsapp.com/send?text=%e3%82%b9%e3%83%88%e3%83%aa%e3%83%bc%e3%83%a0%e5%87%a6%e7%90%86%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0%e3%81%ab%e6%b1%82%e3%82%81%e3%82%89%e3%82%8c%e3%82%8b%e6%a9%9f%e8%83%bd%e6%80%a7%e3%80%81%e3%81%8a%e3%82%88%e3%81%b3%20Apache%20Flink%20%e3%81%ab%e3%81%8a%e3%81%91%e3%82%8b%e3%81%9d%e3%81%ae%e5%af%be%e5%bf%9c%20-%20https%3a%2f%2fsoonraah.github.io%2fposts%2ffunctionality-of-streaming-system%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23-13.314-11.876-22.304-26.542-24.916-31.026s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ストリーム処理システムに求められる機能性、および Apache Flink におけるその対応 on telegram" href="https://telegram.me/share/url?text=%e3%82%b9%e3%83%88%e3%83%aa%e3%83%bc%e3%83%a0%e5%87%a6%e7%90%86%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0%e3%81%ab%e6%b1%82%e3%82%81%e3%82%89%e3%82%8c%e3%82%8b%e6%a9%9f%e8%83%bd%e6%80%a7%e3%80%81%e3%81%8a%e3%82%88%e3%81%b3%20Apache%20Flink%20%e3%81%ab%e3%81%8a%e3%81%91%e3%82%8b%e3%81%9d%e3%81%ae%e5%af%be%e5%bf%9c&url=https%3a%2f%2fsoonraah.github.io%2fposts%2ffunctionality-of-streaming-system%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47A3.38 3.38.0 0126.49 29.86zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2020 <a href=https://soonraah.github.io>Froglog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top" accesskey=g><button class=top-link id=top-link type=button><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button></a>
<script src=https://soonraah.github.io/assets/js/highlight.min.e7afc2928c0925d65c4732dfebe147014d91299a98e819e4b42f25c4fa68e91c.js integrity="sha256-56/CkowJJdZcRzLf6+FHAU2RKZqY6BnktC8lxPpo6Rw="></script><script>hljs.initHighlightingOnLoad();</script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);document.querySelector(`[id='${id}']`).scrollIntoView({behavior:"smooth"});});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>