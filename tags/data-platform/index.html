<!doctype html><html lang=ja dir=auto><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-NSEGH2YT17"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-NSEGH2YT17")</script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Data Platform | Froglog</title>
<meta name=keywords content><meta name=description content="blog"><meta name=author content="soonraah"><link rel=canonical href=https://soonraah.github.io/tags/data-platform/><meta name=google-site-verification content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css integrity="sha256-IhHKMWS+eDACT2qtKzouUghDpk+PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as=style><link rel=icon href=https://soonraah.github.io/favicon2.ico><link rel=icon type=image/png sizes=16x16 href=https://soonraah.github.io/image/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://soonraah.github.io/image/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://soonraah.github.io/static/image/favicon/apple-touch-icon.png><link rel=mask-icon href=https://soonraah.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://soonraah.github.io/tags/data-platform/index.xml><link rel=alternate hreflang=ja href=https://soonraah.github.io/tags/data-platform/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://soonraah.github.io/tags/data-platform/"><meta property="og:site_name" content="Froglog"><meta property="og:title" content="Data Platform"><meta property="og:description" content="blog"><meta property="og:locale" content="ja"><meta property="og:type" content="website"><meta property="og:image" content="https://soonraah.github.io/image/brand/soonraah_full.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://soonraah.github.io/image/brand/soonraah_full.png"><meta name=twitter:title content="Data Platform"><meta name=twitter:description content="blog"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://soonraah.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://soonraah.github.io/image/brand/favicon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://soonraah.github.io/about/ title=About><span>About</span></a></li><li><a href=https://soonraah.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://soonraah.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://soonraah.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://soonraah.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://soonraah.github.io/>ホーム</a>&nbsp;»&nbsp;<a href=https://soonraah.github.io/tags/>Tags</a></div><h1>Data Platform</h1></header><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://soonraah.github.io/image/ordinary-data-plagform-migration/infra-and-delivery.jpg alt="infra and delivery"></figure><header class=entry-header><h2 class=entry-hint-parent>ふつうのデータ基盤移行 - Part 5. IaC と CI/CD 編</h2></header><div class=entry-content><p>このポストについて データ基盤移行について書いていくシリーズです。
シリーズ一覧はこちらから。
前回 Part 4. AI ワークフローで移行作業効率化編では移行するための苦労と効率化について書きました。
今回はがらっと変わって IaC と CI/CD について書きます。
スコープ 今回は開発寄りの話です。
データ基盤の構築にあたり Terraform を使って IaC (Infrastructure as Code) を実現し、さらにそれに基づいて GitHub Actions による CI/CD (Continuous Integration & Continuous Derivery) 環境を作ったという話をしていきます。
IaC で作りたいアーキテクチャは AWS 上の Databricks 環境とその周辺です。
アーキテクチャについて詳しくは Part 3. アーキテクチャ編などをご参照ください。
だいたい以下の図のような話です。
お気持ち表明 こんにちは、初手で絶対に CI/CD 環境を構築するマンです。
初手で絶対に CI/CD 環境を構築するマンは、初手で絶対に CI/CD 環境を構築するぞ！という強い気持ちを持っています。
Databricks 上にデータ基盤を構築するにあたり、他社事例でインフラ構築を自動化していないケースを見たこともあります。
しかし我々のチームでは PoC 終了後の構築最初期から IaC としてインフラをコード化し、それを CI/CD の仕組みで自動でデプロイすることを決めていました。
次のような理由からです。
リリースの数だけ自動化のリターンがあるので、最初から自動化しておくのが最もリターンが大きい チームにはジュニアなメンバーもおり、手動の運用はオペミスや production, staging などの環境差発生のリスクが大きい 社内で Terraform や GitHub Actions などがよく使われており、導入できる下地があった まだ Databricks にそこまで慣れていない導入初期にこれらの仕組みを入れるのはそれなりにたいへんです。
しかしそのたいへんさ以上のメリットがあると判断しました。
...</p></div><footer class=entry-footer><span title='2025-09-18 07:30:00 +0900 JST'>9月 18, 2025</span>&nbsp;·&nbsp;soonraah</footer><a class=entry-link aria-label="post link to ふつうのデータ基盤移行 - Part 5. IaC と CI/CD 編" href=https://soonraah.github.io/posts/ordinary-data-platform-migration-part-5/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://soonraah.github.io/image/finops/finops.jpg alt=finops></figure><header class=entry-header><h2 class=entry-hint-parent>データエンジニアから見るクラウド FinOps</h2></header><div class=entry-content><p>このポストについて 書籍『クラウドFinOps 第2版』を読んだところ、FinOps にデータマネジメントやデータエンジニアリングに深く関連する内容があるということがわかったのでまとめてみる。
書籍について J.R. Storment; Mike Fulle. クラウドFinOps 第2版 協調的でリアルタイムなクラウド価値の意思決定 O’Reilly Japan. 2025年3月に出版。
ちなみに原著の初版は2019年、第2版は2023年。
タイトルのとおり FinOps (後述) について書かれた書籍となっている。
著者は両名とも FinOps Foundation の関係者であり、本文中にも随所に FinOps Foundation についての記載が出てくる。
私はデータエンジニア、ソフトウェアエンジニアとして日々 AWS その他のクラウドサービスを利用している。
クラウドサービス上に例えばデータ基盤等を構築し、ビジネス上の価値を提供している。
その一方でクラウドを使うということは料金的な意味でのコストがかかるということでもある。
もちろん支払うコストは少ない方がいい。
それは分かるのだが、それ以上のクラウドコストについての体系的な考え方を持ち合わせていなかった。
毎日それなりの額を使ってるのにね。
というのが本書を読もうと思った理由だった。
FinOps とは 定義 これを書いている2025年8月現在における FinOps Foundation での定義は以下のようになっている。1
“FinOps is an operational framework and cultural practice which maximizes the business value of cloud and technology, enables timely data-driven decision making, and creates financial accountability through collaboration between engineering, finance, and business teams.”
...</p></div><footer class=entry-footer><span title='2025-08-12 07:00:00 +0900 JST'>8月 12, 2025</span>&nbsp;·&nbsp;soonraah</footer><a class=entry-link aria-label="post link to データエンジニアから見るクラウド FinOps" href=https://soonraah.github.io/posts/cloud-finops-for-data-engineer/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://soonraah.github.io/image/ordinary-data-plagform-migration/workflow.jpg alt=workflow></figure><header class=entry-header><h2 class=entry-hint-parent>ふつうのデータ基盤移行 - Part 4. AI ワークフローで移行作業効率化編</h2></header><div class=entry-content><p>このポストについて データ基盤移行について書いていくシリーズです。
シリーズ一覧はこちらから。
前回 Part 3. アーキテクチャ編ではどういったシステム構成にしたかを書きました。
今回はその技術スタックへと移行するための苦労と効率化について書きます。
(次は CI/CD の話をすると書きましたが…スマンありゃウソだった)
スコープ 今回はやや小さいスコープの話です。
データ基盤における ETL (ELT) 処理の移行作業を対象としています。
移行作業における工数的な課題を AI ワークフローを作って効率化して軽減したという話になります。
ETL 以外の移行作業は今回はスコープ外となります。
課題 旧データ基盤から新データ基盤へと table およびそれを更新するための処理を移行するにあたり工数面での課題が2つあります。
技術スタックの移行 column 命名などの標準化 これらについて述べます。
技術スタックの移行 データ基盤の移行において、新旧の環境で技術スタックは次のようになっています。
旧データ基盤 ETL: Glue Job 新データ基盤 ELT: dbt-databricks つまり Glue Job の Python コードを dbt model、つまり SQL に翻訳する必要があり、それなりに手間がかかります。
さらにこの Python コードは次のような問題もあり、移行のハードルを上げます。
UDF を実装して特殊な処理を行っているケースがある Spark の API だけでなく Glue の API をふんだんに使っている (なるべく Spark に寄せればいいものを…) (ここ数年の業務で見た中で一番というぐらいに) コード品質が低い column 命名などの標準化 旧データ基盤は利用者への配慮があまりない状態で table の schema が作られており、利用者にとって使いにくいものとなっていました。
それを改善するため、新データ基盤では次のようなルールを導入しました。
...</p></div><footer class=entry-footer><span title='2025-06-18 07:30:00 +0900 JST'>6月 18, 2025</span>&nbsp;·&nbsp;soonraah</footer><a class=entry-link aria-label="post link to ふつうのデータ基盤移行 - Part 4. AI ワークフローで移行作業効率化編" href=https://soonraah.github.io/posts/ordinary-data-platform-migration-part-4/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://soonraah.github.io/image/ordinary-data-plagform-migration/medalists.jpg alt="medallion architecture"></figure><header class=entry-header><h2 class=entry-hint-parent>ふつうのデータ基盤移行 - Part 3. アーキテクチャ編</h2></header><div class=entry-content><p>このポストについて データ基盤移行について書いていくシリーズです。
シリーズ一覧はこちらから。
前回 Part 2. 技術選定編では技術選定について書きました。
今回はそれを踏まえた結果としてどのようなアーキテクチャになったかを書きます。
スコープ 前回の記事ではプラットフォームとして Databricks を選定したことやその経緯について記載しました。
一方、それより詳細な技術スタックを含むシステムアーキテクチャについては示していませんでした。
例えばデータ基盤では通常次のような技術スタックについて考える必要があります。
データ取込 workflow orchestration ELT (or ETL) storage これらについて述べ、またデータ基盤の階層構造についても説明します。
システムアーキテクチャ データ基盤のシステム・アーキテクチャです。
よく混同されがちですが、データアーキテクチャではありません。
AWS + Databricks の構成をベースとして構築されています。
概要図 データ取込 現時点ではデータソースとしては S3 に置かれた半構造化データ (JSON)、RDS がメインとなっています。
これら2つの取込方法について述べます。
まず、S3 のデータは SQL の copy into 文により取り込んでいます。
Get started using COPY INTO to load data | Databricks Documentation Auto Loader を使う方が Databricks 的でありそれも検討したのですが、schema evolution や冪等性など検討した結果として copy into を採用しました。
RDS からのデータ取込は foreign catalog 経由で行います。
...</p></div><footer class=entry-footer><span title='2025-06-11 08:30:00 +0900 JST'>6月 11, 2025</span>&nbsp;·&nbsp;soonraah</footer><a class=entry-link aria-label="post link to ふつうのデータ基盤移行 - Part 3. アーキテクチャ編" href=https://soonraah.github.io/posts/ordinary-data-platform-migration-part-3/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://soonraah.github.io/image/ordinary-data-plagform-migration/technology-selection.jpg alt="technology selection"></figure><header class=entry-header><h2 class=entry-hint-parent>ふつうのデータ基盤移行 - Part 2. 技術選定編</h2></header><div class=entry-content><p>このポストについて データ基盤移行について書いていくシリーズです。
シリーズ一覧はこちらから。
前回は戦略策定 (実際は戦術) までのところを書きました。
今回はそれを踏まえた技術選定、およびその後の予算獲得について書いていきます。
また、こちらは Databricks Advent Calendar 2024 シリーズ 2 の16日目の記事にもなっています。
はいそうです、出落ちですが技術選定として Databricks を選ぶことになります。
スコープ 前回 Part 1. 戦略策定編では概ねのロードマップが決まり、まずはデータ基盤のリアーキテクチャをやっていくことになりました。
リアーキテクチャにおいてはどのような技術スタックを使っていくかが重要な選択になります。
データ基盤においてはデータ処理のためのストレージとコンピュートの選択がとても重要です。
以降ではこの2つをあわせた DWH 製品の選定について書いていきます。
「DHW 製品」という言葉は適切ではないかもしれませんが、ここではストレージ + コンピュートが組み合わさったものぐらいに考えてください。
もちろんデータ基盤には他の技術要素もあり、それらも軽くない選択ですがこのポストでは割愛します。
(気が向いたら別記事で書くかも)
技術選定の目的 まず何のために技術スタックの置き換え、ひいては技術選定をするかの目的を明確にしておく必要があります。
旧データ基盤では次のような技術スタックになっていました。
ストレージ: S3 コンピュート: Glue Job, Athena この構成には次のような課題がありました。
主にこれらの課題を解決するために DWH 製品の乗り換えを検討することになりました。
dbt との親和性の低さ 一貫したガバナンスの欠如 dbt との親和性の低さ 前回作成したロードマップにおいて、dbt の導入が課題解決における重要なポイントになっています。
dbt の周辺エコシステムがデータ基盤の課題の解決に大きく貢献すると考えています。
また、データパイプラインの開発・運用の負荷も dbt 導入で軽減できそうです。
旧データ基盤では Glue Job と Athena クエリを組み合わせた複雑なパイプラインになっており、table を1つ追加するだけでもいろいろなコードに手をいれる必要があります。
ほぼ SQL で実装でき、かつ宣言的にパイプライン構築できる dbt は魅力的です。
仮に旧データ基盤に dbt を導入するとなると dbt-athena を使うことになります。
ただ dbt による Athena のサポートはやや弱く、dbt-athena はコミュニティ版から少し前に移管されたものですし、これを書いている2024年12月の時点で dbt Cloud の Athena のサポートはまだプレビューです。
反論がある方もいらっしゃるかもしれませんが、モダンなデータ基盤構築において Athena はやや影が薄い印象があり、dbt のサポートの弱さもこれが原因だと思います。
(ただし直近の re:Invent 2024 の内容からすると潮目が変わる可能性もありそうです)
...</p></div><footer class=entry-footer><span title='2024-12-16 00:30:00 +0900 JST'>12月 16, 2024</span>&nbsp;·&nbsp;soonraah</footer><a class=entry-link aria-label="post link to ふつうのデータ基盤移行 - Part 2. 技術選定編" href=https://soonraah.github.io/posts/ordinary-data-platform-migration-part-2/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://soonraah.github.io/image/ordinary-data-plagform-migration/stragist-frog.jpg alt="data strategy"></figure><header class=entry-header><h2 class=entry-hint-parent>ふつうのデータ基盤移行 - Part 1. 戦略策定編</h2></header><div class=entry-content><p>このポストについて データ基盤移行について書かれた各社の技術ブログなど見かけることがありますが、割とさらっと書かれていることが多いように思います。
本当はいろんな面で苦労があり、記事に表れていない辛さや工夫などがあるはず。
ということで今自分が経験している普通の会社の普通のデータ基盤移行について、詳しく記事にしてみようと考えました。
何回かに分けてデータ基盤移行のいろいろな側面を、うまくいったこともいかなかったことも含めて書いていきます。
とはいえ現在進行形なので、全編書き終わるのはかなり先になりそうです。
データ基盤移行のシリーズ一覧はこちらから。
移行の背景 組織 まずイメージしやすいよう、どういった組織におけるデータ基盤移行なのかについて軽く触れておきます。
社員規模: 〜100名 web 系の B2C ビジネス データチームの構成 マネージャ: 1名 (データエンジニアリングの経験はほぼない) データエンジニア: 2 -> 3名 (途中で採用) 中小のベンチャー？企業ではありますが、意思決定プロセスは JTC 感があります。
私はデータエンジニアのポジションとなっており、その視点からの話であることにご留意ください。
小さい組織ということで私は移行の計画から設計、開発その他のあらゆるフェーズに中心的に関わっています。
どこもそうだと思いますが、人員的にはまあまあきびしい。
よくある中小 IT 企業のよくあるデータ基盤移行の話だと思っていただきたく。
大企業ではないのでそこまでちゃんとはしていません。
(ちなみに自分のブログで本件を記事にしていいかは上長に確認の上、OK をもらっています)
旧データ基盤 一連のポストでは移行前のデータ基盤のことを「旧データ基盤」と表記するものとします。
旧データ基盤は AWS 上で構築されており、アーキテクチャについて簡単に挙げると
storage: S3 ETL: Glue Job, Athena SQL engine: Athena workflow orchestration: MWAA のようになっていました。
旧データ基盤の開発・運用側 (データエンジニア) としても、また社内の利用者側としてもいろいろと問題が挙がってきてはいました。
しかしそれをうまく集約・言語化できていないという状況でした。
そんな中でエライ人の鶴の一声で移行しようぜ！ということになり、データ基盤の移行を検討することに相成りました。
移行計画を考えるにあたり まず考えたこと データ基盤の移行は組織におけるデータマネジメントにおいて重要な位置づけとなるはず。
したがって単なる技術スタックの置き換えというスコープで考えるのはもったいないです。
組織のデータマネジメントの未来を想定して、戦略を持って開発・運用を進めるべきであると考えました。
そのためにはイシューを明確化しないといけません。
でもどの抽象度レベルで？
ボトムアップの戦術策定 まずは現場感覚、ボトムアップでの課題を明らかにすることを考えました。
本来は後述する戦略レベルから先に考えるべきですが、実際に目に見えている課題があり、取り組みやすかったというところで戦術のレベルから考え始めています。(良し悪しはある)
現状のアーキテクチャと運用では戦略策定への対応が難しいため、せめてそのための地ならしとして今見えている課題に対応できる状態にしたいというのもありました。
...</p></div><footer class=entry-footer><span title='2024-12-01 22:30:00 +0900 JST'>12月 1, 2024</span>&nbsp;·&nbsp;soonraah</footer><a class=entry-link aria-label="post link to ふつうのデータ基盤移行 - Part 1. 戦略策定編" href=https://soonraah.github.io/posts/ordinary-data-platform-migration-part-1/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://soonraah.github.io/>Froglog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>